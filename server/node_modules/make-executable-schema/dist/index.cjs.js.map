{"version":3,"file":"index.cjs.js","sources":["../src/Interfaces.ts","../src/utils/map.ts","../src/utils/filterSchema.ts","../src/utils/clone.ts","../src/utils/stub.ts","../src/utils/heal.ts","../src/utils/SchemaVisitor.ts","../src/utils/valueFromASTUntyped.ts","../src/utils/visitSchema.ts","../src/utils/inspect.ts","../src/utils/getArgumentValues.ts","../src/utils/SchemaDirectiveVisitor.ts","../src/utils/getResolversFromSchema.ts","../src/utils/forEachField.ts","../src/utils/forEachDefaultValue.ts","../src/utils/transformInputValue.ts","../src/addResolvers/checkForResolveTypeResolver.ts","../src/addResolvers/extendResolversFromInterfaces.ts","../src/addResolvers/addResolversToSchema.ts","../src/generate/addSchemaLevelResolver.ts","../src/generate/assertResolversPresent.ts","../src/generate/attachDirectiveResolvers.ts","../src/generate/extensionDefinitions.ts","../src/generate/concatenateTypeDefs.ts","../src/generate/buildSchemaFromTypeDefinitions.ts","../src/generate/chainResolvers.ts","../src/generate/decorateWithLogger.ts","../src/utils/mergeDeep.ts","../src/generate/makeExecutableSchema.ts","../src/mock/index.ts","../src/scalars/GraphQLUpload.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLField,\n  GraphQLInputType,\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLIsTypeOfFn,\n  GraphQLTypeResolver,\n  GraphQLScalarType,\n  DocumentNode,\n  FieldNode,\n  GraphQLEnumValue,\n  GraphQLEnumType,\n  GraphQLUnionType,\n  GraphQLArgument,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  InlineFragmentNode,\n  GraphQLOutputType,\n  SelectionSetNode,\n  GraphQLDirective,\n  GraphQLFieldConfig,\n  FragmentDefinitionNode,\n  SelectionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n  GraphQLError,\n  ExecutionResult as GraphQLExecutionResult,\n  BuildSchemaOptions,\n} from 'graphql';\n\nimport { SchemaVisitor } from './utils/SchemaVisitor';\nimport { SchemaDirectiveVisitor } from './utils/SchemaDirectiveVisitor';\n\nexport type SchemaDirectiveVisitorClass = typeof SchemaDirectiveVisitor;\n\n// graphql-js < v15 backwards compatible ExecutionResult\n// See: https://github.com/graphql/graphql-js/pull/2490\n\nexport interface ExecutionResult<TData = Record<string, any>>\n  extends GraphQLExecutionResult {\n  data?: TData | null;\n  extensions?: Record<string, any>;\n}\n\n// for backwards compatibility\nexport type Result = ExecutionResult;\n\n// graphql-js non-exported typings\n\nexport type TypeMap = Record<string, GraphQLNamedType>;\n\nexport interface GraphQLExecutionContext {\n  schema: GraphQLSchema;\n  fragments: Record<string, FragmentDefinitionNode>;\n  rootValue: any;\n  contextValue: any;\n  operation: OperationDefinitionNode;\n  variableValues: Record<string, any>;\n  fieldResolver: GraphQLFieldResolver<any, any>;\n  errors: Array<GraphQLError>;\n}\n\nexport interface GraphQLParseOptions {\n  noLocation?: boolean;\n  allowLegacySDLEmptyFields?: boolean;\n  allowLegacySDLImplementsInterfaces?: boolean;\n  experimentalFragmentVariables?: boolean;\n}\n\n// graphql-tools typings\n\nexport interface IResolverValidationOptions {\n  requireResolversForArgs?: boolean;\n  requireResolversForNonScalar?: boolean;\n  requireResolversForAllFields?: boolean;\n  requireResolversForResolveType?: boolean;\n  allowResolversNotInSchema?: boolean;\n}\n\n// for backwards compatibility\nexport interface IAddResolveFunctionsToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  defaultFieldResolver: IFieldResolver<any, any>;\n  resolverValidationOptions: IResolverValidationOptions;\n  inheritResolversFromInterfaces: boolean;\n}\n\nexport interface IAddResolversToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  defaultFieldResolver?: IFieldResolver<any, any>;\n  resolverValidationOptions?: IResolverValidationOptions;\n  inheritResolversFromInterfaces?: boolean;\n}\n\nexport interface IResolverOptions<TSource = any, TContext = any, TArgs = any> {\n  fragment?: string;\n  resolve?: IFieldResolver<TSource, TContext, TArgs>;\n  subscribe?: IFieldResolver<TSource, TContext, TArgs>;\n  extensions?: Record<string, any>;\n  __resolveType?: GraphQLTypeResolver<TSource, TContext>;\n  __isTypeOf?: GraphQLIsTypeOfFn<TSource, TContext>;\n}\n\nexport interface Transform {\n  transformSchema?: (originalSchema: GraphQLSchema) => GraphQLSchema;\n  transformRequest?: (originalRequest: Request) => Request;\n  transformResult?: (originalResult: ExecutionResult) => ExecutionResult;\n}\n\nexport type FieldTransformer = (\n  typeName: string,\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => GraphQLFieldConfig<any, any> | RenamedFieldConfig | null | undefined;\n\nexport type RootFieldTransformer = (\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => GraphQLFieldConfig<any, any> | RenamedFieldConfig | null | undefined;\n\nexport type FieldNodeTransformer = (\n  typeName: string,\n  fieldName: string,\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionNode | Array<SelectionNode>;\n\nexport type FieldNodeMapper = (\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionNode | Array<SelectionNode>;\n\nexport type FieldNodeMappers = Record<string, Record<string, FieldNodeMapper>>;\n\nexport interface RenamedFieldConfig {\n  name: string;\n  field?: GraphQLFieldConfig<any, any>;\n}\n\nexport type FieldFilter = (\n  typeName?: string,\n  fieldName?: string,\n  field?: GraphQLField<any, any>,\n) => boolean;\n\nexport type RootFieldFilter = (\n  operation?: 'Query' | 'Mutation' | 'Subscription',\n  rootFieldName?: string,\n  field?: GraphQLField<any, any>,\n) => boolean;\n\nexport type RenameTypesOptions = {\n  renameBuiltins: boolean;\n  renameScalars: boolean;\n};\n\ndeclare module 'graphql' {\n  interface GraphQLResolveInfo {\n    mergeInfo?: MergeInfo;\n  }\n}\n\nexport interface ExecutionParams<TArgs = Record<string, any>, TContext = any> {\n  document: DocumentNode;\n  variables?: TArgs;\n  context?: TContext;\n  info?: GraphQLResolveInfo;\n}\nexport type Executor = (\n  params: ExecutionParams,\n) => Promise<ExecutionResult> | ExecutionResult;\nexport type Subscriber = (\n  params: ExecutionParams,\n) => Promise<AsyncIterator<ExecutionResult> | ExecutionResult>;\n\nexport interface SubschemaConfig {\n  schema: GraphQLSchema;\n  rootValue?: Record<string, any>;\n  executor?: Executor;\n  subscriber?: Subscriber;\n  createProxyingResolver?: CreateProxyingResolverFn;\n  transforms?: Array<Transform>;\n  merge?: Record<string, MergedTypeConfig>;\n}\n\nexport interface MergedTypeConfig {\n  selectionSet?: string;\n  fieldName?: string;\n  args?: (originalResult: any) => Record<string, any>;\n  resolve?: MergedTypeResolver;\n}\n\nexport type MergedTypeResolver = (\n  originalResult: any,\n  context: Record<string, any>,\n  info: GraphQLResolveInfo,\n  subschema: GraphQLSchema | SubschemaConfig,\n  selectionSet: SelectionSetNode,\n) => any;\n\nexport interface GraphQLSchemaWithTransforms extends GraphQLSchema {\n  transforms?: Array<Transform>;\n}\n\nexport type MergeTypeCandidate = {\n  type: GraphQLNamedType;\n  schema?: GraphQLSchema;\n  subschema?: GraphQLSchema | SubschemaConfig;\n  transformedSubschema?: GraphQLSchema;\n};\n\nexport type MergeTypeFilter = (\n  mergeTypeCandidates: Array<MergeTypeCandidate>,\n  typeName: string,\n) => boolean;\n\nexport interface IMakeRemoteExecutableSchemaOptions {\n  schema: GraphQLSchema | string;\n  executor?: Executor;\n  subscriber?: Subscriber;\n  createResolver?: (\n    executor: Executor,\n    subscriber: Subscriber,\n  ) => GraphQLFieldResolver<any, any>;\n  buildSchemaOptions?: BuildSchemaOptions;\n}\n\nexport interface IStitchSchemasOptions {\n  subschemas?: Array<GraphQLSchema | SubschemaConfig>;\n  types?: Array<GraphQLNamedType>;\n  typeDefs?: string | DocumentNode;\n  schemas?: Array<SchemaLikeObject>;\n  onTypeConflict?: OnTypeConflict;\n  resolvers?: IResolversParameter;\n  schemaDirectives?: Record<string, SchemaDirectiveVisitorClass>;\n  inheritResolversFromInterfaces?: boolean;\n  mergeTypes?: boolean | Array<string> | MergeTypeFilter;\n  mergeDirectives?: boolean;\n  queryTypeName?: string;\n  mutationTypeName?: string;\n  subscriptionTypeName?: string;\n}\n\nexport type SchemaLikeObject =\n  | SubschemaConfig\n  | GraphQLSchema\n  | string\n  | DocumentNode\n  | Array<GraphQLNamedType>;\n\nexport function isSubschemaConfig(\n  value: SchemaLikeObject,\n): value is SubschemaConfig {\n  return Boolean((value as SubschemaConfig).schema);\n}\n\nexport interface IDelegateToSchemaOptions<\n  TContext = Record<string, any>,\n  TArgs = Record<string, any>\n> {\n  schema: GraphQLSchema | SubschemaConfig;\n  operation?: Operation;\n  fieldName?: string;\n  returnType?: GraphQLOutputType;\n  args?: TArgs;\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n  context?: TContext;\n  info: GraphQLResolveInfo;\n  rootValue?: Record<string, any>;\n  transforms?: Array<Transform>;\n  skipValidation?: boolean;\n  skipTypeMerging?: boolean;\n}\n\nexport interface ICreateRequestFromInfo {\n  info: GraphQLResolveInfo;\n  operation: Operation;\n  fieldName: string;\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n}\n\nexport interface ICreateRequest {\n  sourceSchema?: GraphQLSchema;\n  sourceParentType?: GraphQLObjectType;\n  sourceFieldName?: string;\n  fragments?: Record<string, FragmentDefinitionNode>;\n  variableDefinitions?: ReadonlyArray<VariableDefinitionNode>;\n  variableValues?: Record<string, any>;\n  targetOperation: Operation;\n  targetFieldName: string;\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n}\n\nexport interface IDelegateRequestOptions extends IDelegateToSchemaOptions {\n  request: Request;\n}\n\nexport interface MergeInfo {\n  delegate: (\n    type: 'query' | 'mutation' | 'subscription',\n    fieldName: string,\n    args: Record<string, any>,\n    context: Record<string, any>,\n    info: GraphQLResolveInfo,\n    transforms?: Array<Transform>,\n  ) => any;\n  fragments: Array<{\n    field: string;\n    fragment: string;\n  }>;\n  replacementSelectionSets: ReplacementSelectionSetMapping;\n  replacementFragments: ReplacementFragmentMapping;\n  mergedTypes: Record<string, MergedTypeInfo>;\n  delegateToSchema<TContext, TArgs>(\n    options: IDelegateToSchemaOptions<TContext, TArgs>,\n  ): any;\n}\n\nexport interface ReplacementSelectionSetMapping {\n  [typeName: string]: { [fieldName: string]: SelectionSetNode };\n}\n\nexport interface ReplacementFragmentMapping {\n  [typeName: string]: { [fieldName: string]: InlineFragmentNode };\n}\n\nexport interface MergedTypeInfo {\n  subschemas: Array<SubschemaConfig>;\n  selectionSet?: SelectionSetNode;\n  uniqueFields: Record<string, SubschemaConfig>;\n  nonUniqueFields: Record<string, Array<SubschemaConfig>>;\n  typeMaps: Map<SubschemaConfig, TypeMap>;\n  selectionSets: Map<SubschemaConfig, SelectionSetNode>;\n  containsSelectionSet: Map<SubschemaConfig, Map<SelectionSetNode, boolean>>;\n}\n\nexport type IFieldResolver<\n  TSource,\n  TContext,\n  TArgs = Record<string, any>,\n  TReturn = any\n> = (\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => TReturn;\n\nexport type ITypedef = (() => Array<ITypedef>) | string | DocumentNode;\n\nexport type ITypeDefinitions = ITypedef | Array<ITypedef>;\n\nexport interface IResolverObject<TSource = any, TContext = any, TArgs = any> {\n  [key: string]:\n    | IFieldResolver<TSource, TContext, TArgs>\n    | IResolverOptions<TSource, TContext>\n    | IResolverObject<TSource, TContext>;\n}\n\nexport type IEnumResolver = Record<string, string | number>;\n\nexport type IResolvers<TSource = any, TContext = any> = Record<\n  string,\n  | (() => any)\n  | IResolverObject<TSource, TContext>\n  | IResolverOptions<TSource, TContext>\n  | GraphQLScalarType\n  | IEnumResolver\n>;\n\nexport type IResolversParameter =\n  | Array<IResolvers | ((mergeInfo: MergeInfo) => IResolvers)>\n  | IResolvers\n  | ((mergeInfo: MergeInfo) => IResolvers);\n\nexport interface ILogger {\n  log: (error: Error) => void;\n}\n\nexport interface IExecutableSchemaDefinition<TContext = any> {\n  typeDefs: ITypeDefinitions;\n  resolvers?: IResolvers<any, TContext> | Array<IResolvers<any, TContext>>;\n  logger?: ILogger;\n  allowUndefinedInResolve?: boolean;\n  resolverValidationOptions?: IResolverValidationOptions;\n  directiveResolvers?: IDirectiveResolvers<any, TContext>;\n  schemaDirectives?: Record<string, SchemaDirectiveVisitorClass>;\n  parseOptions?: GraphQLParseOptions;\n  inheritResolversFromInterfaces?: boolean;\n}\n\nexport type IFieldIteratorFn = (\n  fieldDef: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) => void;\n\nexport type IDefaultValueIteratorFn = (\n  type: GraphQLInputType,\n  value: any,\n) => void;\n\nexport type NextResolverFn = () => Promise<any>;\n\nexport type DirectiveResolverFn<TSource = any, TContext = any> = (\n  next: NextResolverFn,\n  source: TSource,\n  args: { [argName: string]: any },\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => any;\n\nexport interface IDirectiveResolvers<TSource = any, TContext = any> {\n  [directiveName: string]: DirectiveResolverFn<TSource, TContext>;\n}\n\n/* XXX on mocks, args are optional, Not sure if a bug. */\nexport type IMockFn = GraphQLFieldResolver<any, any>;\n\nexport interface IMocks {\n  [key: string]: IMockFn;\n}\n\nexport type IMockTypeFn = (\n  type: GraphQLType,\n  typeName?: string,\n  fieldName?: string,\n) => GraphQLFieldResolver<any, any>;\n\nexport interface IMockOptions {\n  schema?: GraphQLSchema;\n  mocks?: IMocks;\n  preserveResolvers?: boolean;\n}\n\nexport interface IMockServer {\n  query: (\n    query: string,\n    vars?: Record<string, any>,\n  ) => Promise<ExecutionResult>;\n}\n\nexport type OnTypeConflict = (\n  left: GraphQLNamedType,\n  right: GraphQLNamedType,\n  info?: {\n    left: {\n      schema?: GraphQLSchema | SubschemaConfig;\n    };\n    right: {\n      schema?: GraphQLSchema | SubschemaConfig;\n    };\n  },\n) => GraphQLNamedType;\n\nexport type Operation = 'query' | 'mutation' | 'subscription';\n\nexport interface Request {\n  document: DocumentNode;\n  variables: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport type IndexedObject<V> = Record<string, V> | ReadonlyArray<V>;\n\nexport type VisitableSchemaType =\n  | GraphQLSchema\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLInputObjectType\n  | GraphQLNamedType\n  | GraphQLScalarType\n  | GraphQLField<any, any>\n  | GraphQLInputField\n  | GraphQLArgument\n  | GraphQLUnionType\n  | GraphQLEnumType\n  | GraphQLEnumValue;\n\nexport type VisitorSelector = (\n  type: VisitableSchemaType,\n  methodName: string,\n) => Array<SchemaVisitor | SchemaVisitorMap>;\n\nexport enum VisitSchemaKind {\n  TYPE = 'VisitSchemaKind.TYPE',\n  SCALAR_TYPE = 'VisitSchemaKind.SCALAR_TYPE',\n  ENUM_TYPE = 'VisitSchemaKind.ENUM_TYPE',\n  COMPOSITE_TYPE = 'VisitSchemaKind.COMPOSITE_TYPE',\n  OBJECT_TYPE = 'VisitSchemaKind.OBJECT_TYPE',\n  INPUT_OBJECT_TYPE = 'VisitSchemaKind.INPUT_OBJECT_TYPE',\n  ABSTRACT_TYPE = 'VisitSchemaKind.ABSTRACT_TYPE',\n  UNION_TYPE = 'VisitSchemaKind.UNION_TYPE',\n  INTERFACE_TYPE = 'VisitSchemaKind.INTERFACE_TYPE',\n  ROOT_OBJECT = 'VisitSchemaKind.ROOT_OBJECT',\n  QUERY = 'VisitSchemaKind.QUERY',\n  MUTATION = 'VisitSchemaKind.MUTATION',\n  SUBSCRIPTION = 'VisitSchemaKind.SUBSCRIPTION',\n}\n\nexport interface SchemaVisitorMap {\n  [VisitSchemaKind.TYPE]?: NamedTypeVisitor;\n  [VisitSchemaKind.SCALAR_TYPE]?: ScalarTypeVisitor;\n  [VisitSchemaKind.ENUM_TYPE]?: EnumTypeVisitor;\n  [VisitSchemaKind.COMPOSITE_TYPE]?: CompositeTypeVisitor;\n  [VisitSchemaKind.OBJECT_TYPE]?: ObjectTypeVisitor;\n  [VisitSchemaKind.INPUT_OBJECT_TYPE]?: InputObjectTypeVisitor;\n  [VisitSchemaKind.ABSTRACT_TYPE]?: AbstractTypeVisitor;\n  [VisitSchemaKind.UNION_TYPE]?: UnionTypeVisitor;\n  [VisitSchemaKind.INTERFACE_TYPE]?: InterfaceTypeVisitor;\n  [VisitSchemaKind.ROOT_OBJECT]?: ObjectTypeVisitor;\n  [VisitSchemaKind.QUERY]?: ObjectTypeVisitor;\n  [VisitSchemaKind.MUTATION]?: ObjectTypeVisitor;\n  [VisitSchemaKind.SUBSCRIPTION]?: ObjectTypeVisitor;\n}\n\nexport type NamedTypeVisitor = (\n  type: GraphQLNamedType,\n  schema: GraphQLSchema,\n) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeVisitor = (\n  type: GraphQLScalarType,\n  schema: GraphQLSchema,\n) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeVisitor = (\n  type: GraphQLEnumType,\n  schema: GraphQLSchema,\n) => GraphQLEnumType | null | undefined;\n\nexport type CompositeTypeVisitor = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) =>\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | null\n  | undefined;\n\nexport type ObjectTypeVisitor = (\n  type: GraphQLObjectType,\n  schema: GraphQLSchema,\n) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeVisitor = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema,\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeVisitor = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeVisitor = (\n  type: GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeVisitor = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | null | undefined;\n\nexport enum MapperKind {\n  TYPE = 'MapperKind.TYPE',\n  SCALAR_TYPE = 'MapperKind.SCALAR_TYPE',\n  ENUM_TYPE = 'MapperKind.ENUM_TYPE',\n  COMPOSITE_TYPE = 'MapperKind.COMPOSITE_TYPE',\n  OBJECT_TYPE = 'MapperKind.OBJECT_TYPE',\n  INPUT_OBJECT_TYPE = 'MapperKind.INPUT_OBJECT_TYPE',\n  ABSTRACT_TYPE = 'MapperKind.ABSTRACT_TYPE',\n  UNION_TYPE = 'MapperKind.UNION_TYPE',\n  INTERFACE_TYPE = 'MapperKind.INTERFACE_TYPE',\n  ROOT_OBJECT = 'MapperKind.ROOT_OBJECT',\n  QUERY = 'MapperKind.QUERY',\n  MUTATION = 'MapperKind.MUTATION',\n  SUBSCRIPTION = 'MapperKind.SUBSCRIPTION',\n  DIRECTIVE = 'MapperKind.DIRECTIVE',\n}\n\nexport interface SchemaMapper {\n  [MapperKind.TYPE]?: NamedTypeMapper;\n  [MapperKind.SCALAR_TYPE]?: ScalarTypeMapper;\n  [MapperKind.ENUM_TYPE]?: EnumTypeMapper;\n  [MapperKind.COMPOSITE_TYPE]?: CompositeTypeMapper;\n  [MapperKind.OBJECT_TYPE]?: ObjectTypeMapper;\n  [MapperKind.INPUT_OBJECT_TYPE]?: InputObjectTypeMapper;\n  [MapperKind.ABSTRACT_TYPE]?: AbstractTypeMapper;\n  [MapperKind.UNION_TYPE]?: UnionTypeMapper;\n  [MapperKind.INTERFACE_TYPE]?: InterfaceTypeMapper;\n  [MapperKind.ROOT_OBJECT]?: ObjectTypeMapper;\n  [MapperKind.QUERY]?: ObjectTypeMapper;\n  [MapperKind.MUTATION]?: ObjectTypeMapper;\n  [MapperKind.SUBSCRIPTION]?: ObjectTypeMapper;\n  [MapperKind.DIRECTIVE]?: DirectiveMapper;\n}\n\nexport type NamedTypeMapper = (\n  type: GraphQLNamedType,\n  schema: GraphQLSchema,\n) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeMapper = (\n  type: GraphQLScalarType,\n  schema: GraphQLSchema,\n) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeMapper = (\n  type: GraphQLEnumType,\n  schema: GraphQLSchema,\n) => GraphQLEnumType | null | undefined;\n\nexport type CompositeTypeMapper = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) =>\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | null\n  | undefined;\n\nexport type ObjectTypeMapper = (\n  type: GraphQLObjectType,\n  schema: GraphQLSchema,\n) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeMapper = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema,\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeMapper = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeMapper = (\n  type: GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeMapper = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | null | undefined;\n\nexport type DirectiveMapper = (\n  directive: GraphQLDirective,\n  schema: GraphQLSchema,\n) => GraphQLDirective | null | undefined;\n\nexport type CreateProxyingResolverFn = (\n  schema: GraphQLSchema | SubschemaConfig,\n  transforms: Array<Transform>,\n  operation: Operation,\n  fieldName: string,\n) => GraphQLFieldResolver<any, any>;\n","import {\n  GraphQLDirective,\n  GraphQLEnumType,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLType,\n  GraphQLUnionType,\n  isDirective,\n  isInterfaceType,\n  isEnumType,\n  isInputType,\n  isInputObjectType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n  isSpecifiedScalarType,\n} from 'graphql';\n\nimport {\n  SchemaMapper,\n  MapperKind,\n  NamedTypeMapper,\n  DirectiveMapper,\n} from '../Interfaces';\n\nexport function mapSchema(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper = {},\n): GraphQLSchema {\n  const originalTypeMap = schema.getTypeMap();\n  const newTypeMap = Object.create(null);\n  Object.keys(originalTypeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      const typeMapper = getMapper(\n        schema,\n        schemaMapper,\n        originalTypeMap[typeName],\n      );\n\n      if (typeMapper != null) {\n        const newType = typeMapper(originalTypeMap[typeName], schema);\n        newTypeMap[typeName] =\n          newType !== undefined ? newType : originalTypeMap[typeName];\n      } else {\n        newTypeMap[typeName] = originalTypeMap[typeName];\n      }\n    }\n  });\n\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n\n  const newQueryTypeName =\n    queryType != null\n      ? newTypeMap[queryType.name] != null\n        ? newTypeMap[queryType.name].name\n        : undefined\n      : undefined;\n  const newMutationTypeName =\n    mutationType != null\n      ? newTypeMap[mutationType.name] != null\n        ? newTypeMap[mutationType.name].name\n        : undefined\n      : undefined;\n  const newSubscriptionTypeName =\n    subscriptionType != null\n      ? newTypeMap[subscriptionType.name] != null\n        ? newTypeMap[subscriptionType.name].name\n        : undefined\n      : undefined;\n\n  const originalDirectives = schema.getDirectives();\n  const newDirectives: Array<GraphQLDirective> = [];\n  originalDirectives.forEach((directive) => {\n    const directiveMapper = getMapper(schema, schemaMapper, directive);\n    if (directiveMapper != null) {\n      const newDirective = directiveMapper(directive, schema);\n      if (newDirective != null) {\n        newDirectives.push(newDirective);\n      }\n    } else {\n      newDirectives.push(directive);\n    }\n  });\n\n  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n\n  return new GraphQLSchema({\n    ...schema.toConfig(),\n    query: newQueryTypeName\n      ? (typeMap[newQueryTypeName] as GraphQLObjectType)\n      : undefined,\n    mutation: newMutationTypeName\n      ? (typeMap[newMutationTypeName] as GraphQLObjectType)\n      : undefined,\n    subscription:\n      newSubscriptionTypeName != null\n        ? (typeMap[newSubscriptionTypeName] as GraphQLObjectType)\n        : undefined,\n    types: Object.keys(typeMap).map((typeName) => typeMap[typeName]),\n    directives,\n  });\n}\n\nfunction getTypeSpecifiers(\n  type: GraphQLType,\n  schema: GraphQLSchema,\n): Array<MapperKind> {\n  const specifiers = [MapperKind.TYPE];\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n    if (type === query) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(\n      MapperKind.COMPOSITE_TYPE,\n      MapperKind.ABSTRACT_TYPE,\n      MapperKind.INTERFACE_TYPE,\n    );\n  } else if (isUnionType(type)) {\n    specifiers.push(\n      MapperKind.COMPOSITE_TYPE,\n      MapperKind.ABSTRACT_TYPE,\n      MapperKind.UNION_TYPE,\n    );\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: GraphQLNamedType,\n): NamedTypeMapper | null;\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: GraphQLDirective,\n): DirectiveMapper | null;\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: any,\n): any {\n  if (isNamedType(typeOrDirective)) {\n    const specifiers = getTypeSpecifiers(typeOrDirective, schema);\n    let typeMapper: NamedTypeMapper | undefined;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n      const next = stack.pop();\n      typeMapper = schemaMapper[next] as NamedTypeMapper;\n    }\n\n    return typeMapper != null ? typeMapper : null;\n  } else if (isDirective(typeOrDirective)) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n  }\n}\n\nexport function rewireTypes(\n  originalTypeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n): {\n  typeMap: Record<string, GraphQLNamedType>;\n  directives: Array<GraphQLDirective>;\n} {\n  const newTypeMap: Record<string, GraphQLNamedType> = Object.create(null);\n\n  Object.keys(originalTypeMap).forEach((typeName) => {\n    const namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const newName = namedType.name;\n    if (newName.startsWith('__')) {\n      return;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  });\n\n  Object.keys(newTypeMap).forEach((typeName) => {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  });\n\n  const newDirectives = directives.map((directive) =>\n    rewireDirective(directive),\n  );\n\n  return pruneTypes(newTypeMap, newDirectives);\n\n  function rewireDirective(directive: GraphQLDirective): GraphQLDirective {\n    const directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(\n    args: GraphQLFieldConfigArgumentMap,\n  ): GraphQLFieldConfigArgumentMap {\n    const rewiredArgs = {};\n    Object.keys(args).forEach((argName) => {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    });\n    return rewiredArgs;\n  }\n\n  function rewireNamedType<T extends GraphQLNamedType>(type: T) {\n    if (isObjectType(type)) {\n      const config = type.toConfig() as any;\n      const newConfig = {\n        ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces),\n      };\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      const config = type.toConfig() as any;\n      const newConfig = {\n        ...config,\n        fields: () => rewireFields(config.fields),\n      };\n      if ('interfaces' in newConfig) {\n        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n      }\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type)) {\n      const config = type.toConfig() as any;\n      const newConfig = {\n        ...config,\n        types: () => rewireNamedTypes(config.types),\n      };\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type)) {\n      const config = type.toConfig() as any;\n      const newConfig = {\n        ...config,\n        fields: () => rewireInputFields(config.fields),\n      };\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type)) {\n      const enumConfig = type.toConfig() as any;\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n      const scalarConfig = type.toConfig() as any;\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${(type as unknown) as string}`);\n  }\n\n  function rewireFields(\n    fields: GraphQLFieldConfigMap<any, any>,\n  ): GraphQLFieldConfigMap<any, any> {\n    const rewiredFields = {};\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireInputFields(\n    fields: GraphQLInputFieldConfigMap,\n  ): GraphQLInputFieldConfigMap {\n    const rewiredFields = {};\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes<T extends GraphQLNamedType>(\n    namedTypes: Array<T>,\n  ): Array<T> {\n    const rewiredTypes: Array<T> = [];\n    namedTypes.forEach((namedType) => {\n      const rewiredType = rewireType(namedType);\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    });\n    return rewiredTypes;\n  }\n\n  function rewireType<T extends GraphQLType>(type: T): T | null {\n    if (isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? (new GraphQLList(rewiredType) as T) : null;\n    } else if (isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null\n        ? (new GraphQLNonNull(rewiredType) as T)\n        : null;\n    } else if (isNamedType(type)) {\n      const originalType = originalTypeMap[type.name];\n      return originalType != null ? (newTypeMap[originalType.name] as T) : null;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(\n  typeMap: Record<string, GraphQLNamedType>,\n  directives: Array<GraphQLDirective>,\n): {\n  typeMap: Record<string, GraphQLNamedType>;\n  directives: Array<GraphQLDirective>;\n} {\n  const newTypeMap = {};\n\n  const implementedInterfaces = {};\n  Object.keys(typeMap).forEach((typeName) => {\n    const namedType = typeMap[typeName];\n\n    if ('getInterfaces' in namedType) {\n      namedType.getInterfaces().forEach((iface) => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (Object.keys(type.getFields()).length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (type.getTypes().length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (\n        Object.keys(type.getFields()).length &&\n        implementedInterfaces[type.name]\n      ) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else {\n      newTypeMap[typeName] = type;\n    }\n  }\n\n  // every prune requires another round of healing\n  return prunedTypeMap\n    ? rewireTypes(newTypeMap, directives)\n    : { typeMap, directives };\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  GraphQLType,\n  GraphQLField,\n} from 'graphql';\n\nimport {\n  GraphQLSchemaWithTransforms,\n  MapperKind,\n  FieldFilter,\n  RootFieldFilter,\n} from '../Interfaces';\n\nimport { mapSchema } from './map';\n\nexport default function filterSchema({\n  schema,\n  rootFieldFilter = () => true,\n  typeFilter = () => true,\n  fieldFilter = () => true,\n}: {\n  schema: GraphQLSchemaWithTransforms;\n  rootFieldFilter?: RootFieldFilter;\n  typeFilter?: (typeName: string, type: GraphQLType) => boolean;\n  fieldFilter?: (typeName: string, fieldName: string) => boolean;\n}): GraphQLSchemaWithTransforms {\n  const filteredSchema: GraphQLSchemaWithTransforms = mapSchema(schema, {\n    [MapperKind.QUERY]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Query', rootFieldFilter),\n    [MapperKind.MUTATION]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Mutation', rootFieldFilter),\n    [MapperKind.SUBSCRIPTION]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Subscription', rootFieldFilter),\n    [MapperKind.OBJECT_TYPE]: (type: GraphQLObjectType) =>\n      typeFilter(type.name, type)\n        ? filterObjectFields(type, fieldFilter)\n        : null,\n    [MapperKind.INTERFACE_TYPE]: (type: GraphQLInterfaceType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.UNION_TYPE]: (type: GraphQLUnionType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.INPUT_OBJECT_TYPE]: (type: GraphQLInputObjectType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.ENUM_TYPE]: (type: GraphQLEnumType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.SCALAR_TYPE]: (type: GraphQLScalarType) =>\n      typeFilter(type.name, type) ? undefined : null,\n  });\n\n  filteredSchema.transforms = schema.transforms;\n\n  return filteredSchema;\n}\n\nfunction filterRootFields(\n  type: GraphQLObjectType,\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  rootFieldFilter: RootFieldFilter,\n): GraphQLObjectType {\n  const config = type.toConfig();\n  Object.keys(config.fields).forEach((fieldName) => {\n    if (\n      !rootFieldFilter(\n        operation,\n        fieldName,\n        (config.fields[fieldName] as unknown) as GraphQLField<any, any>,\n      )\n    ) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction filterObjectFields(\n  type: GraphQLObjectType,\n  fieldFilter: FieldFilter,\n): GraphQLObjectType {\n  const config = type.toConfig();\n  Object.keys(config.fields).forEach((fieldName) => {\n    if (\n      !fieldFilter(\n        type.name,\n        fieldName,\n        (config.fields[fieldName] as unknown) as GraphQLField<any, any>,\n      )\n    ) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n","import {\n  GraphQLDirective,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  isEnumType,\n  isScalarType,\n  isSpecifiedScalarType,\n} from 'graphql';\n\nimport { mapSchema } from './map';\n\nexport function cloneDirective(directive: GraphQLDirective): GraphQLDirective {\n  return new GraphQLDirective(directive.toConfig());\n}\n\nexport function cloneType(type: GraphQLNamedType): GraphQLNamedType {\n  if (isObjectType(type)) {\n    const config = type.toConfig();\n    return new GraphQLObjectType({\n      ...config,\n      interfaces:\n        typeof config.interfaces === 'function'\n          ? config.interfaces\n          : config.interfaces.slice(),\n    });\n  } else if (isInterfaceType(type)) {\n    const config = type.toConfig() as any;\n    const newConfig = {\n      ...config,\n      interfaces: [\n        ...((typeof config.interfaces === 'function'\n          ? config.interfaces()\n          : config.interfaces) || []),\n      ],\n    };\n    return new GraphQLInterfaceType(newConfig);\n  } else if (isUnionType(type)) {\n    const config = type.toConfig();\n    return new GraphQLUnionType({\n      ...config,\n      types: config.types.slice(),\n    });\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType(type.toConfig());\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType(type.toConfig());\n  } else if (isScalarType(type)) {\n    return isSpecifiedScalarType(type)\n      ? type\n      : new GraphQLScalarType(type.toConfig());\n  }\n\n  throw new Error(`Invalid type ${type as string}`);\n}\n\nexport function cloneSchema(schema: GraphQLSchema): GraphQLSchema {\n  return mapSchema(schema);\n}\n","import {\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLInputObjectType,\n  GraphQLString,\n  GraphQLNamedType,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  isObjectType,\n  isInterfaceType,\n  isInputObjectType,\n  TypeNode,\n  Kind,\n  GraphQLType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLOutputType,\n  GraphQLInputType,\n} from 'graphql';\n\nexport function createNamedStub(\n  name: string,\n  type: 'object',\n): GraphQLObjectType;\nexport function createNamedStub(\n  name: string,\n  type: 'interface',\n): GraphQLInterfaceType;\nexport function createNamedStub(\n  name: string,\n  type: 'input',\n): GraphQLInputObjectType;\nexport function createNamedStub(\n  name: string,\n  type: any,\n): GraphQLObjectType | GraphQLInterfaceType | GraphQLInputObjectType {\n  let constructor: any;\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      __fake: {\n        type: GraphQLString,\n      },\n    },\n  });\n}\n\nexport function createStub(node: TypeNode, type: 'output'): GraphQLOutputType;\nexport function createStub(node: TypeNode, type: 'input'): GraphQLInputType;\nexport function createStub(\n  node: TypeNode,\n  type: 'output' | 'input',\n): GraphQLType;\nexport function createStub(node: TypeNode, type: any): any {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(createStub(node.type, type));\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(createStub(node.type, type));\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nexport function isNamedStub(type: GraphQLNamedType): boolean {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    const fields = type.getFields();\n    const fieldNames = Object.keys(fields);\n    return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n  }\n\n  return false;\n}\n\nexport function getBuiltInForStub(type: GraphQLNamedType): GraphQLNamedType {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n    case GraphQLString.name:\n      return GraphQLString;\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n    case GraphQLID.name:\n      return GraphQLID;\n    default:\n      return type;\n  }\n}\n","import {\n  GraphQLDirective,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLType,\n  GraphQLUnionType,\n  isNamedType,\n  GraphQLSchema,\n  GraphQLInputType,\n  GraphQLOutputType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from 'graphql';\n\nimport { isNamedStub, getBuiltInForStub } from './stub';\n\ntype NamedTypeMap = Record<string, GraphQLNamedType>;\n\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\nexport function healSchema(schema: GraphQLSchema): GraphQLSchema {\n  const typeMap = schema.getTypeMap();\n  const directives = schema.getDirectives();\n\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n\n  const newQueryTypeName =\n    queryType != null\n      ? typeMap[queryType.name] != null\n        ? typeMap[queryType.name].name\n        : undefined\n      : undefined;\n  const newMutationTypeName =\n    mutationType != null\n      ? typeMap[mutationType.name] != null\n        ? typeMap[mutationType.name].name\n        : undefined\n      : undefined;\n  const newSubscriptionTypeName =\n    subscriptionType != null\n      ? typeMap[subscriptionType.name] != null\n        ? typeMap[subscriptionType.name].name\n        : undefined\n      : undefined;\n\n  healTypes(typeMap, directives);\n\n  const filteredTypeMap = {};\n\n  Object.keys(typeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      filteredTypeMap[typeName] = typeMap[typeName];\n    }\n  });\n\n  const healedSchema = new GraphQLSchema({\n    ...schema.toConfig(),\n    query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined,\n    mutation: newMutationTypeName\n      ? filteredTypeMap[newMutationTypeName]\n      : undefined,\n    subscription: newSubscriptionTypeName\n      ? filteredTypeMap[newSubscriptionTypeName]\n      : undefined,\n    types: Object.keys(filteredTypeMap).map(\n      (typeName) => filteredTypeMap[typeName],\n    ),\n    directives: directives.slice(),\n  });\n\n  // Reconstruct the schema to reinitialize private variables\n  // e.g. the stored implementation map and the proper root types.\n  Object.assign(schema, healedSchema);\n\n  return schema;\n}\n\nexport function healTypes(\n  originalTypeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n  config: {\n    skipPruning: boolean;\n  } = {\n    skipPruning: false,\n  },\n) {\n  const actualNamedTypeMap: NamedTypeMap = Object.create(null);\n\n  // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const actualName = namedType.name;\n    if (actualName.startsWith('__')) {\n      return;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType;\n\n    // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  });\n\n  // Now add back every named type by its actual name.\n  Object.entries(actualNamedTypeMap).forEach(([typeName, namedType]) => {\n    originalTypeMap[typeName] = namedType;\n  });\n\n  // Directive declaration argument types can refer to named types.\n  directives.forEach((decl: GraphQLDirective) => {\n    decl.args = decl.args.filter((arg) => {\n      arg.type = healType(arg.type) as GraphQLInputType;\n      return arg.type !== null;\n    });\n  });\n\n  Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n    // Heal all named types, except for dangling references, kept only to redirect.\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  });\n\n  for (const typeName of Object.keys(originalTypeMap)) {\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      delete originalTypeMap[typeName];\n    }\n  }\n\n  if (!config.skipPruning) {\n    pruneTypes(originalTypeMap, directives);\n  }\n\n  function healNamedType(type: GraphQLNamedType) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type as string}`);\n  }\n\n  function healFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    const fieldMap = type.getFields();\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.args\n        .map((arg) => {\n          arg.type = healType(arg.type) as GraphQLInputType;\n          return arg.type === null ? null : arg;\n        })\n        .filter(Boolean);\n      field.type = healType(field.type) as GraphQLOutputType;\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healInterfaces(type: GraphQLObjectType | GraphQLInterfaceType) {\n    if ('getInterfaces' in type) {\n      const interfaces = type.getInterfaces();\n      interfaces.push(\n        ...interfaces\n          .splice(0)\n          .map((iface) => healType(iface) as any)\n          .filter(Boolean),\n      );\n    }\n  }\n\n  function healInputFields(type: GraphQLInputObjectType) {\n    const fieldMap = type.getFields();\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.type = healType(field.type) as GraphQLInputType;\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healUnderlyingTypes(type: GraphQLUnionType) {\n    const types = type.getTypes();\n    types.push(\n      ...types\n        .splice(0)\n        .map((t) => healType(t) as any)\n        .filter(Boolean),\n    );\n  }\n\n  function healType<T extends GraphQLType>(type: T): GraphQLType | null {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLNonNull(healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      let officialType = originalTypeMap[type.name];\n      if (officialType === undefined) {\n        if (isNamedStub(type)) {\n          officialType = getBuiltInForStub(type);\n        } else {\n          officialType = type;\n        }\n        originalTypeMap[type.name] = officialType;\n      }\n      return officialType;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(\n  typeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n) {\n  const implementedInterfaces = {};\n  Object.values(typeMap).forEach((namedType) => {\n    if ('getInterfaces' in namedType) {\n      namedType.getInterfaces().forEach((iface) => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (!Object.keys(type.getFields()).length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (!type.getTypes().length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (\n        !Object.keys(type.getFields()).length ||\n        !(type.name in implementedInterfaces)\n      ) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    }\n  }\n\n  // every prune requires another round of healing\n  if (prunedTypeMap) {\n    healTypes(typeMap, directives);\n  }\n}\n","import {\n  GraphQLArgument,\n  GraphQLEnumType,\n  GraphQLEnumValue,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n} from 'graphql';\n\n// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nexport abstract class SchemaVisitor {\n  // All SchemaVisitor instances are created while visiting a specific\n  // GraphQLSchema object, so this property holds a reference to that object,\n  // in case a visitor method needs to refer to this.schema.\n  public schema!: GraphQLSchema;\n\n  // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n  public static implementsVisitorMethod(methodName: string): boolean {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    const method = this.prototype[methodName];\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this.name === 'SchemaVisitor') {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    const stub = SchemaVisitor.prototype[methodName];\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  }\n\n  // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitSchema(_schema: GraphQLSchema): void {}\n\n  public visitScalar(\n    _scalar: GraphQLScalarType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLScalarType | void | null {}\n\n  public visitObject(\n    _object: GraphQLObjectType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLObjectType | void | null {}\n\n  public visitFieldDefinition(\n    _field: GraphQLField<any, any>,\n    _details: {\n      objectType: GraphQLObjectType | GraphQLInterfaceType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLField<any, any> | void | null {}\n\n  public visitArgumentDefinition(\n    _argument: GraphQLArgument,\n    _details: {\n      field: GraphQLField<any, any>;\n      objectType: GraphQLObjectType | GraphQLInterfaceType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLArgument | void | null {}\n\n  public visitInterface(\n    _iface: GraphQLInterfaceType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInterfaceType | void | null {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitUnion(_union: GraphQLUnionType): GraphQLUnionType | void | null {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitEnum(_type: GraphQLEnumType): GraphQLEnumType | void | null {}\n\n  public visitEnumValue(\n    _value: GraphQLEnumValue,\n    _details: {\n      enumType: GraphQLEnumType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLEnumValue | void | null {}\n\n  public visitInputObject(\n    _object: GraphQLInputObjectType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInputObjectType | void | null {}\n\n  public visitInputFieldDefinition(\n    _field: GraphQLInputField,\n    _details: {\n      objectType: GraphQLInputObjectType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInputField | void | null {}\n}\n","import { ValueNode, Kind } from 'graphql';\n\n// Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\nexport default function valueFromASTUntyped(valueNode: ValueNode): any {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map(valueFromASTUntyped);\n    case Kind.OBJECT: {\n      return valueNode.fields.reduce(\n        (prev, field) => ({\n          ...prev,\n          [field.name.value]: valueFromASTUntyped(field.value),\n        }),\n        {},\n      );\n    }\n    /* istanbul ignore next */\n    default:\n      throw new Error('Unexpected value kind: ' + valueNode.kind);\n  }\n}\n","import {\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  isNamedType,\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInputField,\n  isSchema,\n  isObjectType,\n  isInterfaceType,\n  isInputObjectType,\n  isScalarType,\n  isUnionType,\n  isEnumType,\n  isInputType,\n  GraphQLEnumValue,\n  GraphQLEnumType,\n} from 'graphql';\n\nimport {\n  VisitableSchemaType,\n  VisitorSelector,\n  VisitSchemaKind,\n  NamedTypeVisitor,\n  SchemaVisitorMap,\n} from '../Interfaces';\n\nimport { healSchema } from './heal';\nimport { SchemaVisitor } from './SchemaVisitor';\n\nfunction isSchemaVisitor(obj: any): obj is SchemaVisitor {\n  if ('schema' in obj && isSchema(obj.schema)) {\n    if ('visitSchema' in obj && typeof obj.visitSchema === 'function') {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Generic function for visiting GraphQLSchema objects.\nexport function visitSchema(\n  schema: GraphQLSchema,\n  // To accommodate as many different visitor patterns as possible, the\n  // visitSchema function does not simply accept a single instance of the\n  // SchemaVisitor class, but instead accepts a function that takes the\n  // current VisitableSchemaType object and the name of a visitor method and\n  // returns an array of SchemaVisitor instances that implement the visitor\n  // method and have an interest in handling the given VisitableSchemaType\n  // object. In the simplest case, this function can always return an array\n  // containing a single visitor object, without even looking at the type or\n  // methodName parameters. In other cases, this function might sometimes\n  // return an empty array to indicate there are no visitors that should be\n  // applied to the given VisitableSchemaType object. For an example of a\n  // visitor pattern that benefits from this abstraction, see the\n  // SchemaDirectiveVisitor class below.\n  visitorOrVisitorSelector:\n    | VisitorSelector\n    | Array<SchemaVisitor | SchemaVisitorMap>\n    | SchemaVisitor\n    | SchemaVisitorMap,\n): GraphQLSchema {\n  const visitorSelector =\n    typeof visitorOrVisitorSelector === 'function'\n      ? visitorOrVisitorSelector\n      : () => visitorOrVisitorSelector;\n\n  // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n  function callMethod<T extends VisitableSchemaType>(\n    methodName: string,\n    type: T,\n    ...args: Array<any>\n  ): T | null {\n    let visitors = visitorSelector(type, methodName);\n    visitors = Array.isArray(visitors) ? visitors : [visitors];\n\n    let finalType: T | null = type;\n    visitors.every((visitorOrVisitorDef) => {\n      let newType;\n      if (isSchemaVisitor(visitorOrVisitorDef)) {\n        newType = visitorOrVisitorDef[methodName](finalType, ...args);\n      } else if (\n        isNamedType(finalType) &&\n        (methodName === 'visitScalar' ||\n          methodName === 'visitEnum' ||\n          methodName === 'visitObject' ||\n          methodName === 'visitInputObject' ||\n          methodName === 'visitUnion' ||\n          methodName === 'visitInterface')\n      ) {\n        const specifiers = getTypeSpecifiers(finalType, schema);\n        const typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\n        newType =\n          typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\n      }\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || isSchema(finalType)) {\n        throw new Error(\n          `Method ${methodName} cannot replace schema with ${\n            newType as string\n          }`,\n        );\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        finalType = null;\n        return false;\n      }\n\n      // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n      finalType = newType;\n      return true;\n    });\n\n    // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n    return finalType;\n  }\n\n  // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n  function visit<T extends VisitableSchemaType>(type: T): T | null {\n    if (isSchema(type)) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n\n      const typeMap: Record<\n        string,\n        GraphQLNamedType | null\n      > = type.getTypeMap();\n      Object.entries(typeMap).forEach(([typeName, namedType]) => {\n        if (!typeName.startsWith('__') && namedType != null) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map.\n          // We do not use updateEachKey because we want to preserve\n          // deleted types in the typeMap so that other types that reference\n          // the deleted types can be healed.\n          typeMap[typeName] = visit(namedType);\n        }\n      });\n\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      const newObject = callMethod('visitObject', type);\n      if (newObject != null) {\n        visitFields(newObject);\n      }\n      return newObject;\n    }\n\n    if (isInterfaceType(type)) {\n      const newInterface = callMethod('visitInterface', type);\n      if (newInterface != null) {\n        visitFields(newInterface);\n      }\n      return newInterface;\n    }\n\n    if (isInputObjectType(type)) {\n      const newInputObject = callMethod('visitInputObject', type);\n\n      if (newInputObject != null) {\n        const fieldMap = newInputObject.getFields() as Record<\n          string,\n          GraphQLInputField\n        >;\n        for (const key of Object.keys(fieldMap)) {\n          fieldMap[key] = callMethod(\n            'visitInputFieldDefinition',\n            fieldMap[key],\n            {\n              // Since we call a different method for input object fields, we\n              // can't reuse the visitFields function here.\n              objectType: newInputObject,\n            },\n          );\n          if (!fieldMap[key]) {\n            delete fieldMap[key];\n          }\n        }\n      }\n\n      return newInputObject;\n    }\n\n    if (isScalarType(type)) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (isUnionType(type)) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (isEnumType(type)) {\n      let newEnum = callMethod('visitEnum', type);\n\n      if (newEnum != null) {\n        const newValues: Array<GraphQLEnumValue> = newEnum\n          .getValues()\n          .map((value) =>\n            callMethod('visitEnumValue', value, {\n              enumType: newEnum,\n            }),\n          )\n          .filter(Boolean);\n\n        // Recreate the enum type if any of the values changed\n        const valuesUpdated = newValues.some(\n          (value, index) => value !== newEnum.getValues()[index],\n        );\n        if (valuesUpdated) {\n          newEnum = new GraphQLEnumType({\n            ...(newEnum as GraphQLEnumType).toConfig(),\n            values: newValues.reduce(\n              (prev, value) => ({\n                ...prev,\n                [value.name]: {\n                  value: value.value,\n                  deprecationReason: value.deprecationReason,\n                  description: value.description,\n                  astNode: value.astNode,\n                },\n              }),\n              {},\n            ),\n          }) as GraphQLEnumType & T;\n        }\n      }\n\n      return newEnum;\n    }\n\n    throw new Error(`Unexpected schema type: ${(type as unknown) as string}`);\n  }\n\n  function visitFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    const fieldMap = type.getFields();\n    for (const [key, field] of Object.entries(fieldMap)) {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      const newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type,\n      });\n\n      if (newField.args != null) {\n        newField.args = newField.args\n          .map((arg) =>\n            callMethod('visitArgumentDefinition', arg, {\n              // Like visitFieldDefinition, visitArgumentDefinition takes a\n              // second parameter that provides additional context, namely the\n              // parent .field and grandparent .objectType. Remember that the\n              // current GraphQLSchema is always available via this.schema.\n              field: newField,\n              objectType: type,\n            }),\n          )\n          .filter(Boolean);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (newField) {\n        fieldMap[key] = newField;\n      } else {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  visit(schema);\n\n  // Automatically update any references to named schema types replaced\n  // during the traversal, so implementors don't have to worry about that.\n  healSchema(schema);\n\n  // Return schema for convenience, even though schema parameter has all updated types.\n  return schema;\n}\n\nfunction getTypeSpecifiers(\n  type: GraphQLType,\n  schema: GraphQLSchema,\n): Array<VisitSchemaKind> {\n  const specifiers = [VisitSchemaKind.TYPE];\n  if (isObjectType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.OBJECT_TYPE,\n    );\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n    if (type === query) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(\n        VisitSchemaKind.ROOT_OBJECT,\n        VisitSchemaKind.SUBSCRIPTION,\n      );\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.ABSTRACT_TYPE,\n      VisitSchemaKind.INTERFACE_TYPE,\n    );\n  } else if (isUnionType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.ABSTRACT_TYPE,\n      VisitSchemaKind.UNION_TYPE,\n    );\n  } else if (isEnumType(type)) {\n    specifiers.push(VisitSchemaKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getVisitor(\n  visitorDef: SchemaVisitorMap,\n  specifiers: Array<VisitSchemaKind>,\n): NamedTypeVisitor | null {\n  let typeVisitor: NamedTypeVisitor | undefined;\n  const stack = [...specifiers];\n  while (!typeVisitor && stack.length > 0) {\n    const next = stack.pop();\n    typeVisitor = visitorDef[next] as NamedTypeVisitor;\n  }\n\n  return typeVisitor != null ? typeVisitor : null;\n}\n","const MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n\n/**\n * Used to print values in error messages.\n */\nexport function inspect(value: any): string {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value: any, seenValues: Array<any>): string {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n    case 'function':\n      return value.name\n        ? `[function ${(value as Function).name}]`\n        : '[function]';\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n      return formatObjectValue(value, seenValues);\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(\n  value: any,\n  previouslySeenValues: Array<any>,\n): string {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  const seenValues = [...previouslySeenValues, value];\n  const customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    const customValue = customInspectFn.call(value);\n\n    // check for infinite recursion\n    if (customValue !== value) {\n      return typeof customValue === 'string'\n        ? customValue\n        : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object: any, seenValues: Array<any>) {\n  const keys = Object.keys(object);\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  const properties = keys.map((key) => {\n    const value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array: Array<any>, seenValues: Array<any>): string {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(`... ${remaining.toString(10)} more items`);\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(obj: any) {\n  if (typeof obj.inspect === 'function') {\n    return obj.inspect;\n  }\n}\n\nfunction getObjectTag(obj: any): string {\n  const tag = Object.prototype.toString\n    .call(obj)\n    .replace(/^\\[object /, '')\n    .replace(/]$/, '');\n\n  if (tag === 'Object' && typeof obj.constructor === 'function') {\n    const name = obj.constructor.name;\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","import {\n  valueFromAST,\n  GraphQLField,\n  GraphQLDirective,\n  DirectiveNode,\n  FieldNode,\n  isNonNullType,\n  GraphQLError,\n  Kind,\n  print,\n  ArgumentNode,\n} from 'graphql';\n\nimport { inspect } from './inspect';\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(\n  def: GraphQLField<any, any> | GraphQLDirective,\n  node: FieldNode | DirectiveNode,\n  variableValues: Record<string, any> = {},\n): Record<string, any> {\n  const variableMap: Record<string, any> = Object.entries(\n    variableValues,\n  ).reduce(\n    (prev, [key, value]) => ({\n      ...prev,\n      [key]: value,\n    }),\n    {},\n  );\n\n  const coercedValues = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const argumentNodes = node.arguments ?? [];\n  const argNodeMap: Record<string, ArgumentNode> = argumentNodes.reduce(\n    (prev, arg) => ({\n      ...prev,\n      [arg.name.value]: arg,\n    }),\n    {},\n  );\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          node,\n        );\n      }\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      if (variableValues == null || !(variableName in variableMap)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            valueNode,\n          );\n        }\n        continue;\n      }\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        valueNode,\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        valueNode,\n      );\n    }\n    coercedValues[name] = coercedValue;\n  }\n  return coercedValues;\n}\n","import {\n  GraphQLDirective,\n  GraphQLSchema,\n  DirectiveLocationEnum,\n  TypeSystemExtensionNode,\n} from 'graphql';\n\nimport {\n  VisitableSchemaType,\n  SchemaDirectiveVisitorClass,\n} from '../Interfaces';\n\nimport valueFromASTUntyped from './valueFromASTUntyped';\nimport { SchemaVisitor } from './SchemaVisitor';\nimport { visitSchema } from './visitSchema';\nimport { getArgumentValues } from './getArgumentValues';\n\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\nexport class SchemaDirectiveVisitor<\n  TArgs = any,\n  TContext = any\n> extends SchemaVisitor {\n  // The name of the directive this visitor is allowed to visit (that is, the\n  // identifier that appears after the @ character in the schema). Note that\n  // this property is per-instance rather than static because subclasses of\n  // SchemaDirectiveVisitor can be instantiated multiple times to visit\n  // directives of different names. In other words, SchemaDirectiveVisitor\n  // implementations are effectively anonymous, and it's up to the caller of\n  // SchemaDirectiveVisitor.visitSchemaDirectives to assign names to them.\n  public name: string;\n\n  // A map from parameter names to argument values, as obtained from a\n  // specific occurrence of a @directive(arg1: value1, arg2: value2, ...) in\n  // the schema. Visitor methods may refer to this object via this.args.\n  public args: TArgs;\n\n  // A reference to the type object that this visitor was created to visit.\n  public visitedType: VisitableSchemaType;\n\n  // A shared object that will be available to all visitor instances via\n  // this.context. Callers of visitSchemaDirectives can provide their own\n  // object, or just use the default empty object.\n  public context: TContext;\n\n  // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n  public static getDirectiveDeclaration(\n    directiveName: string,\n    schema: GraphQLSchema,\n  ): GraphQLDirective | null | undefined {\n    return schema.getDirective(directiveName);\n  }\n\n  // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n  public static visitSchemaDirectives(\n    schema: GraphQLSchema,\n    // The keys of this object correspond to directive names as they appear\n    // in the schema, and the values should be subclasses (not instances!)\n    // of the SchemaDirectiveVisitor class. This distinction is important\n    // because a new SchemaDirectiveVisitor instance will be created each\n    // time a matching directive is found in the schema AST, with arguments\n    // and other metadata specific to that occurrence. To help prevent the\n    // mistake of passing instances, the SchemaDirectiveVisitor constructor\n    // method is marked as protected.\n    directiveVisitors: Record<string, SchemaDirectiveVisitorClass>,\n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context: Record<string, any> = Object.create(null),\n    // The visitSchemaDirectives method returns a map from directive names to\n    // lists of SchemaDirectiveVisitors created while visiting the schema.\n  ): Record<string, Array<SchemaDirectiveVisitor>> {\n    // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n    const declaredDirectives = this.getDeclaredDirectives(\n      schema,\n      directiveVisitors,\n    );\n\n    // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n    const createdVisitors: Record<string, Array<any>> = Object.keys(\n      directiveVisitors,\n    ).reduce(\n      (prev, item) => ({\n        ...prev,\n        [item]: [],\n      }),\n      {},\n    );\n\n    const directiveVisitorMap: Record<\n      string,\n      typeof SchemaDirectiveVisitor\n    > = Object.entries(directiveVisitors).reduce(\n      (prev, [key, value]) => ({\n        ...prev,\n        [key]: value,\n      }),\n      {},\n    );\n\n    function visitorSelector(\n      type: VisitableSchemaType,\n      methodName: string,\n    ): Array<SchemaDirectiveVisitor> {\n      let directiveNodes = type.astNode != null ? type.astNode.directives : [];\n\n      const extensionASTNodes: ReadonlyArray<TypeSystemExtensionNode> = (type as {\n        extensionASTNodes?: Array<TypeSystemExtensionNode>;\n      }).extensionASTNodes;\n\n      if (extensionASTNodes != null) {\n        extensionASTNodes.forEach((extensionASTNode) => {\n          directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n        });\n      }\n\n      const visitors: Array<SchemaDirectiveVisitor> = [];\n      directiveNodes.forEach((directiveNode) => {\n        const directiveName = directiveNode.name.value;\n        if (!(directiveName in directiveVisitorMap)) {\n          return;\n        }\n\n        const visitorClass = directiveVisitorMap[directiveName];\n\n        // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n        if (!visitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        const decl = declaredDirectives[directiveName];\n        let args: Record<string, any>;\n\n        if (decl != null) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n          if (directiveNode.arguments != null) {\n            directiveNode.arguments.forEach((arg) => {\n              args[arg.name.value] = valueFromASTUntyped(arg.value);\n            });\n          }\n        }\n\n        // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n        visitors.push(\n          new visitorClass({\n            name: directiveName,\n            args,\n            visitedType: type,\n            schema,\n            context,\n          }),\n        );\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach((visitor) => {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector);\n\n    return createdVisitors;\n  }\n\n  protected static getDeclaredDirectives(\n    schema: GraphQLSchema,\n    directiveVisitors: Record<string, SchemaDirectiveVisitorClass>,\n  ): Record<string, GraphQLDirective> {\n    const declaredDirectives: Record<\n      string,\n      GraphQLDirective\n    > = schema.getDirectives().reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: curr,\n      }),\n      {},\n    );\n    // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n    Object.entries(directiveVisitors).forEach(\n      ([directiveName, visitorClass]) => {\n        const decl = visitorClass.getDirectiveDeclaration(\n          directiveName,\n          schema,\n        );\n        if (decl != null) {\n          declaredDirectives[directiveName] = decl;\n        }\n      },\n    );\n\n    Object.entries(declaredDirectives).forEach(([name, decl]) => {\n      if (!(name in directiveVisitors)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n      const visitorClass = directiveVisitors[name];\n\n      decl.locations.forEach((loc) => {\n        const visitorMethodName = directiveLocationToVisitorMethodName(loc);\n        if (\n          SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n          !visitorClass.implementsVisitorMethod(visitorMethodName)\n        ) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(\n            `SchemaDirectiveVisitor for @${name} must implement ${visitorMethodName} method`,\n          );\n        }\n      });\n    });\n\n    return declaredDirectives;\n  }\n\n  // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n  protected constructor(config: {\n    name: string;\n    args: TArgs;\n    visitedType: VisitableSchemaType;\n    schema: GraphQLSchema;\n    context: TContext;\n  }) {\n    super();\n    this.name = config.name;\n    this.args = config.args;\n    this.visitedType = config.visitedType;\n    this.schema = config.schema;\n    this.context = config.context;\n  }\n}\n\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc: DirectiveLocationEnum) {\n  return (\n    'visit' +\n    loc.replace(\n      /([^_]*)_?/g,\n      (_wholeMatch, part: string) =>\n        part.charAt(0).toUpperCase() + part.slice(1).toLowerCase(),\n    )\n  );\n}\n","import {\n  GraphQLSchema,\n  isScalarType,\n  isEnumType,\n  isInterfaceType,\n  isUnionType,\n  isObjectType,\n  isSpecifiedScalarType,\n} from 'graphql';\n\nimport { IResolvers } from '../Interfaces';\n\nimport { cloneType } from './clone';\n\nexport function getResolversFromSchema(schema: GraphQLSchema): IResolvers {\n  const resolvers = Object.create({});\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    if (isScalarType(type)) {\n      if (!isSpecifiedScalarType(type)) {\n        resolvers[typeName] = cloneType(type);\n      }\n    } else if (isEnumType(type)) {\n      resolvers[typeName] = {};\n\n      const values = type.getValues();\n      values.forEach((value) => {\n        resolvers[typeName][value.name] = value.value;\n      });\n    } else if (isInterfaceType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType,\n        };\n      }\n    } else if (isUnionType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType,\n        };\n      }\n    } else if (isObjectType(type)) {\n      resolvers[typeName] = {};\n\n      if (type.isTypeOf != null) {\n        resolvers[typeName].__isTypeOf = type.isTypeOf;\n      }\n\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        const field = fields[fieldName];\n\n        resolvers[typeName][fieldName] = {\n          resolve: field.resolve,\n          subscribe: field.subscribe,\n        };\n      });\n    }\n  });\n\n  return resolvers;\n}\n","import { getNamedType, GraphQLSchema, isObjectType } from 'graphql';\n\nimport { IFieldIteratorFn } from '../Interfaces';\n\nexport function forEachField(\n  schema: GraphQLSchema,\n  fn: IFieldIteratorFn,\n): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    // TODO: maybe have an option to include these?\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n","import {\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInputObjectType,\n} from 'graphql';\n\nimport { IDefaultValueIteratorFn } from '../Interfaces';\n\nexport function forEachDefaultValue(\n  schema: GraphQLSchema,\n  fn: IDefaultValueIteratorFn,\n): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach((fieldName) => {\n          const field = fields[fieldName];\n\n          field.args.forEach((arg) => {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          });\n        });\n      } else if (isInputObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach((fieldName) => {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        });\n      }\n    }\n  });\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputType,\n  GraphQLScalarType,\n  getNullableType,\n  isLeafType,\n  isListType,\n  isInputObjectType,\n} from 'graphql';\n\ntype InputValueTransformer = (\n  type: GraphQLEnumType | GraphQLScalarType,\n  originalValue: any,\n) => any;\n\nexport function transformInputValue(\n  type: GraphQLInputType,\n  value: any,\n  transformer: InputValueTransformer,\n): any {\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return transformer(nullableType, value);\n  } else if (isListType(nullableType)) {\n    return value.map((listMember: any) =>\n      transformInputValue(nullableType.ofType, listMember, transformer),\n    );\n  } else if (isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n    Object.keys(value).forEach((key) => {\n      newValue[key] = transformInputValue(\n        fields[key].type,\n        value[key],\n        transformer,\n      );\n    });\n    return newValue;\n  }\n\n  // unreachable, no other possible return value\n}\n\nexport function serializeInputValue(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\n\nexport function parseInputValue(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\n\nexport function parseInputValueLiteral(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n","import {\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLSchema,\n  isAbstractType,\n} from 'graphql';\n\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\nexport function checkForResolveTypeResolver(\n  schema: GraphQLSchema,\n  requireResolversForResolveType?: boolean,\n) {\n  Object.keys(schema.getTypeMap())\n    .map((typeName) => schema.getType(typeName))\n    .forEach((type: GraphQLUnionType | GraphQLInterfaceType) => {\n      if (!isAbstractType(type)) {\n        return;\n      }\n      if (!type.resolveType) {\n        if (!requireResolversForResolveType) {\n          return;\n        }\n        throw new Error(\n          `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass false into ` +\n            '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.',\n        );\n      }\n    });\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { IResolvers } from '../Interfaces';\n\nexport function extendResolversFromInterfaces(\n  schema: GraphQLSchema,\n  resolvers: IResolvers,\n) {\n  const typeNames = Object.keys({\n    ...schema.getTypeMap(),\n    ...resolvers,\n  });\n\n  const extendedResolvers: IResolvers = {};\n  typeNames.forEach((typeName) => {\n    const typeResolvers = resolvers[typeName];\n    const type = schema.getType(typeName);\n    if ('getInterfaces' in type) {\n      const interfaceResolvers = type\n        .getInterfaces()\n        .map((iFace) => resolvers[iFace.name]);\n      extendedResolvers[typeName] = Object.assign(\n        {},\n        ...interfaceResolvers,\n        typeResolvers,\n      );\n    } else if (typeResolvers != null) {\n      extendedResolvers[typeName] = typeResolvers;\n    }\n  });\n\n  return extendedResolvers;\n}\n","import {\n  GraphQLField,\n  GraphQLEnumType,\n  GraphQLSchema,\n  isSchema,\n  isScalarType,\n  isEnumType,\n  isUnionType,\n  isInterfaceType,\n  isObjectType,\n  GraphQLEnumValueConfigMap,\n} from 'graphql';\n\nimport {\n  IResolvers,\n  IResolverValidationOptions,\n  IAddResolversToSchemaOptions,\n} from '../Interfaces';\nimport { healSchema, forEachField, forEachDefaultValue } from '../utils/index';\nimport {\n  parseInputValue,\n  serializeInputValue,\n} from '../utils/transformInputValue';\n\nimport { checkForResolveTypeResolver } from './checkForResolveTypeResolver';\nimport { extendResolversFromInterfaces } from './extendResolversFromInterfaces';\n\nexport function addResolversToSchema(\n  schemaOrOptions: GraphQLSchema | IAddResolversToSchemaOptions,\n  legacyInputResolvers?: IResolvers,\n  legacyInputValidationOptions?: IResolverValidationOptions,\n): GraphQLSchema {\n  const options: IAddResolversToSchemaOptions = isSchema(schemaOrOptions)\n    ? {\n        schema: schemaOrOptions,\n        resolvers: legacyInputResolvers,\n        resolverValidationOptions: legacyInputValidationOptions,\n      }\n    : schemaOrOptions;\n\n  const {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n  } = options;\n\n  const {\n    allowResolversNotInSchema = false,\n    requireResolversForResolveType,\n  } = resolverValidationOptions;\n\n  const resolvers = inheritResolversFromInterfaces\n    ? extendResolversFromInterfaces(schema, inputResolvers)\n    : inputResolvers;\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(resolvers).forEach((typeName) => {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new Error(\n        `\"${typeName}\" defined in resolvers, but has invalid value \"${\n          resolverValue as string\n        }\". A resolver's value must be of type object or function.`,\n      );\n    }\n\n    const type = schema.getType(typeName);\n\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n\n      throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n    }\n\n    if (isScalarType(type)) {\n      // Support -- without recommending -- overriding default scalar types\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      });\n    } else if (isEnumType(type)) {\n      // We've encountered an enum resolver that is being used to provide an\n      // internal enum value.\n      // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n          throw new Error(\n            `${typeName}.${fieldName} was defined in resolvers, but enum is not in schema`,\n          );\n        }\n      });\n\n      const config = type.toConfig();\n\n      const values = type.getValues();\n      const newValues = values.reduce<GraphQLEnumValueConfigMap>(\n        (prev, value) => ({\n          ...prev,\n          [value.name]: {\n            value: Object.keys(resolverValue).includes(value.name)\n              ? resolverValue[value.name]\n              : value.name,\n            deprecationReason: value.deprecationReason,\n            description: value.description,\n            astNode: value.astNode,\n          },\n        }),\n        {},\n      );\n\n      // healSchema called later to update all fields to new type\n      typeMap[typeName] = new GraphQLEnumType({\n        ...config,\n        values: newValues,\n      });\n    } else if (isUnionType(type)) {\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new Error(\n          `${typeName} was defined in resolvers, but it's not an object`,\n        );\n      });\n    } else if (isObjectType(type) || isInterfaceType(type)) {\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n\n        const fields = type.getFields();\n        const field = fields[fieldName];\n\n        if (field == null) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new Error(\n            `${typeName}.${fieldName} defined in resolvers, but not in schema`,\n          );\n        }\n\n        const fieldResolve = resolverValue[fieldName];\n        if (typeof fieldResolve === 'function') {\n          // for convenience. Allows shorter syntax in resolver definition file\n          field.resolve = fieldResolve;\n        } else {\n          if (typeof fieldResolve !== 'object') {\n            throw new Error(\n              `Resolver ${typeName}.${fieldName} must be object or function`,\n            );\n          }\n          setFieldProperties(field, fieldResolve);\n        }\n      });\n    }\n  });\n\n  checkForResolveTypeResolver(schema, requireResolversForResolveType);\n\n  // serialize all default values prior to healing fields with new scalar/enum types.\n  forEachDefaultValue(schema, serializeInputValue);\n  // schema may have new scalar/enum types that require healing\n  healSchema(schema);\n  // reparse all default values with new parsing functions.\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, (field) => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(\n  field: GraphQLField<any, any>,\n  propertiesObj: Record<string, any>,\n) {\n  Object.keys(propertiesObj).forEach((propertyName) => {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n","import {\n  defaultFieldResolver,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\n\n// wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\nexport function addSchemaLevelResolver(\n  schema: GraphQLSchema,\n  fn: GraphQLFieldResolver<any, any>,\n): void {\n  // TODO test that schema is a schema, fn is a function\n  const rootTypes = [\n    schema.getQueryType(),\n    schema.getMutationType(),\n    schema.getSubscriptionType(),\n  ].filter((x) => Boolean(x));\n  rootTypes.forEach((type) => {\n    if (type != null) {\n      // XXX this should run at most once per request to simulate a true root resolver\n      // for graphql-js this is an approximation that works with queries but not mutations\n      const rootResolveFn = runAtMostOncePerRequest(fn);\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n        // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n        if (type === schema.getSubscriptionType()) {\n          fields[fieldName].resolve = wrapResolver(\n            fields[fieldName].resolve,\n            fn,\n          );\n        } else {\n          fields[fieldName].resolve = wrapResolver(\n            fields[fieldName].resolve,\n            rootResolveFn,\n          );\n        }\n      });\n    }\n  });\n}\n\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(\n  innerResolver: GraphQLFieldResolver<any, any> | undefined,\n  outerResolver: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  return (obj, args, ctx, info) =>\n    resolveMaybePromise(outerResolver(obj, args, ctx, info), (root) => {\n      if (innerResolver != null) {\n        return innerResolver(root, args, ctx, info);\n      }\n      return defaultFieldResolver(root, args, ctx, info);\n    });\n}\n\nfunction isPromise<T>(\n  maybePromise: Promise<T> | T,\n): maybePromise is Promise<T> {\n  return (\n    maybePromise && typeof (maybePromise as Promise<T>).then === 'function'\n  );\n}\n\n// resolvers can be synchronous or asynchronous. if all resolvers\n// in an operation return synchronously, the execution should return\n// synchronously. the maybe-sync/maybe-async nature of resolvers should be\n// preserved\nfunction resolveMaybePromise<T, U>(\n  maybePromise: Promise<T> | T,\n  fulfillmentCallback: (value: T) => U,\n): Promise<U> | U {\n  if (isPromise(maybePromise)) {\n    return maybePromise.then(fulfillmentCallback);\n  }\n  return fulfillmentCallback(maybePromise);\n}\n\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(\n  fn: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  let value: any;\n  const randomNumber = Math.random();\n  return (root, args, ctx, info) => {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n    return value;\n  };\n}\n","import {\n  GraphQLSchema,\n  GraphQLField,\n  getNamedType,\n  isScalarType,\n} from 'graphql';\n\nimport { IResolverValidationOptions } from '../Interfaces';\nimport { forEachField } from '../utils/index';\n\nexport function assertResolversPresent(\n  schema: GraphQLSchema,\n  resolverValidationOptions: IResolverValidationOptions = {},\n): void {\n  const {\n    requireResolversForArgs = false,\n    requireResolversForNonScalar = false,\n    requireResolversForAllFields = false,\n  } = resolverValidationOptions;\n\n  if (\n    requireResolversForAllFields &&\n    (requireResolversForArgs || requireResolversForNonScalar)\n  ) {\n    throw new TypeError(\n      'requireResolversForAllFields takes precedence over the more specific assertions. ' +\n        'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n        'requireResolversForNonScalar, but not a combination of them.',\n    );\n  }\n\n  forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver(field, typeName, fieldName);\n    }\n\n    // requires a resolver on every field that has arguments\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver(field, typeName, fieldName);\n    }\n\n    // requires a resolver on every field that returns a non-scalar type\n    if (\n      requireResolversForNonScalar &&\n      !isScalarType(getNamedType(field.type))\n    ) {\n      expectResolver(field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(\n  field: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) {\n  if (!field.resolve) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Resolver missing for \"${typeName}.${fieldName}\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131`,\n    );\n    return;\n  }\n  if (typeof field.resolve !== 'function') {\n    throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n  }\n}\n","import { GraphQLSchema, GraphQLField, defaultFieldResolver } from 'graphql';\n\nimport { IDirectiveResolvers } from '../Interfaces';\nimport { SchemaDirectiveVisitor } from '../utils/SchemaDirectiveVisitor';\n\nexport function attachDirectiveResolvers(\n  schema: GraphQLSchema,\n  directiveResolvers: IDirectiveResolvers,\n) {\n  if (typeof directiveResolvers !== 'object') {\n    throw new Error(\n      `Expected directiveResolvers to be of type object, got ${typeof directiveResolvers}`,\n    );\n  }\n\n  if (Array.isArray(directiveResolvers)) {\n    throw new Error(\n      'Expected directiveResolvers to be of type object, got Array',\n    );\n  }\n\n  const schemaDirectives = Object.create(null);\n\n  Object.keys(directiveResolvers).forEach((directiveName) => {\n    schemaDirectives[directiveName] = class extends SchemaDirectiveVisitor {\n      public visitFieldDefinition(field: GraphQLField<any, any>) {\n        const resolver = directiveResolvers[directiveName];\n        const originalResolver =\n          field.resolve != null ? field.resolve : defaultFieldResolver;\n        const directiveArgs = this.args;\n        field.resolve = (...args) => {\n          const [source /* original args */, , context, info] = args;\n          return resolver(\n            () =>\n              new Promise((resolve, reject) => {\n                const result = originalResolver.apply(field, args);\n                if (result instanceof Error) {\n                  reject(result);\n                }\n                resolve(result);\n              }),\n            source,\n            directiveArgs,\n            context,\n            info,\n          );\n        };\n      }\n    };\n  });\n\n  SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n}\n","import { DocumentNode, DefinitionNode, Kind } from 'graphql';\n\nexport function extractExtensionDefinitions(ast: DocumentNode) {\n  const extensionDefs = ast.definitions.filter(\n    (def: DefinitionNode) =>\n      def.kind === Kind.OBJECT_TYPE_EXTENSION ||\n      def.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n      def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\n      def.kind === Kind.UNION_TYPE_EXTENSION ||\n      def.kind === Kind.ENUM_TYPE_EXTENSION ||\n      def.kind === Kind.SCALAR_TYPE_EXTENSION ||\n      def.kind === Kind.SCHEMA_EXTENSION,\n  );\n\n  return {\n    ...ast,\n    definitions: extensionDefs,\n  };\n}\n\nexport function filterExtensionDefinitions(ast: DocumentNode) {\n  const extensionDefs = ast.definitions.filter(\n    (def: DefinitionNode) =>\n      def.kind !== Kind.OBJECT_TYPE_EXTENSION &&\n      def.kind !== Kind.INTERFACE_TYPE_EXTENSION &&\n      def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION &&\n      def.kind !== Kind.UNION_TYPE_EXTENSION &&\n      def.kind !== Kind.ENUM_TYPE_EXTENSION &&\n      def.kind !== Kind.SCALAR_TYPE_EXTENSION &&\n      def.kind !== Kind.SCHEMA_EXTENSION,\n  );\n\n  return {\n    ...ast,\n    definitions: extensionDefs,\n  };\n}\n","import { print, ASTNode } from 'graphql';\n\nimport { ITypedef } from '../Interfaces';\n\nexport function concatenateTypeDefs(\n  typeDefinitionsAry: Array<ITypedef>,\n  calledFunctionRefs = [] as any,\n): string {\n  let resolvedTypeDefinitions: Array<string> = [];\n  typeDefinitionsAry.forEach((typeDef: ITypedef) => {\n    if (typeof typeDef === 'function') {\n      if (calledFunctionRefs.indexOf(typeDef) === -1) {\n        calledFunctionRefs.push(typeDef);\n        resolvedTypeDefinitions = resolvedTypeDefinitions.concat(\n          concatenateTypeDefs(typeDef(), calledFunctionRefs),\n        );\n      }\n    } else if (typeof typeDef === 'string') {\n      resolvedTypeDefinitions.push(typeDef.trim());\n    } else if ((typeDef as ASTNode).kind !== undefined) {\n      resolvedTypeDefinitions.push(print(typeDef).trim());\n    } else {\n      const type = typeof typeDef;\n      throw new Error(\n        `typeDef array must contain only strings and functions, got ${type}`,\n      );\n    }\n  });\n  return uniq(resolvedTypeDefinitions.map((x) => x.trim())).join('\\n');\n}\n\nfunction uniq(array: Array<any>): Array<any> {\n  return array.reduce(\n    (accumulator, currentValue) =>\n      accumulator.indexOf(currentValue) === -1\n        ? [...accumulator, currentValue]\n        : accumulator,\n    [],\n  );\n}\n","import {\n  parse,\n  extendSchema,\n  buildASTSchema,\n  GraphQLSchema,\n  DocumentNode,\n  ASTNode,\n} from 'graphql';\n\nimport { ITypeDefinitions, GraphQLParseOptions } from '../Interfaces';\n\nimport {\n  extractExtensionDefinitions,\n  filterExtensionDefinitions,\n} from './extensionDefinitions';\nimport { concatenateTypeDefs } from './concatenateTypeDefs';\n\nexport function buildSchemaFromTypeDefinitions(\n  typeDefinitions: ITypeDefinitions,\n  parseOptions?: GraphQLParseOptions,\n): GraphQLSchema {\n  // TODO: accept only array here, otherwise interfaces get confusing.\n  let myDefinitions = typeDefinitions;\n  let astDocument: DocumentNode;\n\n  if (isDocumentNode(typeDefinitions)) {\n    astDocument = typeDefinitions;\n  } else if (typeof myDefinitions !== 'string') {\n    if (!Array.isArray(myDefinitions)) {\n      const type = typeof myDefinitions;\n      throw new Error(\n        `typeDefs must be a string, array or schema AST, got ${type}`,\n      );\n    }\n    myDefinitions = concatenateTypeDefs(myDefinitions);\n  }\n\n  if (typeof myDefinitions === 'string') {\n    astDocument = parse(myDefinitions, parseOptions);\n  }\n\n  const typesAst = filterExtensionDefinitions(astDocument);\n\n  const backcompatOptions = { commentDescriptions: true };\n  let schema: GraphQLSchema = buildASTSchema(typesAst, backcompatOptions);\n\n  const extensionsAst = extractExtensionDefinitions(astDocument);\n  if (extensionsAst.definitions.length > 0) {\n    schema = extendSchema(schema, extensionsAst, backcompatOptions);\n  }\n\n  return schema;\n}\n\nfunction isDocumentNode(\n  typeDefinitions: ITypeDefinitions,\n): typeDefinitions is DocumentNode {\n  return (typeDefinitions as ASTNode).kind !== undefined;\n}\n","import {\n  defaultFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLFieldResolver,\n} from 'graphql';\n\nexport function chainResolvers(\n  resolvers: Array<GraphQLFieldResolver<any, any>>,\n) {\n  return (\n    root: any,\n    args: { [argName: string]: any },\n    ctx: any,\n    info: GraphQLResolveInfo,\n  ) =>\n    resolvers.reduce((prev, curResolver) => {\n      if (curResolver != null) {\n        return curResolver(prev, args, ctx, info);\n      }\n\n      return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n","import { defaultFieldResolver, GraphQLFieldResolver } from 'graphql';\n\nimport { ILogger } from '../Interfaces';\n\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nexport function decorateWithLogger(\n  fn: GraphQLFieldResolver<any, any>,\n  logger: ILogger,\n  hint: string,\n): GraphQLFieldResolver<any, any> {\n  const resolver = fn != null ? fn : defaultFieldResolver;\n\n  const logError = (e: Error) => {\n    // TODO: clone the error properly\n    const newE = new Error();\n    newE.stack = e.stack;\n    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n    if (hint) {\n      newE['originalMessage'] = e.message;\n      newE['message'] = `Error in resolver ${hint}\\n${e.message}`;\n    }\n    logger.log(newE);\n  };\n\n  return (root, args, ctx, info) => {\n    try {\n      const result = resolver(root, args, ctx, info);\n      // If the resolver returns a Promise log any Promise rejects.\n      if (\n        result &&\n        typeof result.then === 'function' &&\n        typeof result.catch === 'function'\n      ) {\n        result.catch((reason: Error | string) => {\n          // make sure that it's an error we're logging.\n          const error = reason instanceof Error ? reason : new Error(reason);\n          logError(error);\n\n          // We don't want to leave an unhandled exception so pass on error.\n          return reason;\n        });\n      }\n      return result;\n    } catch (e) {\n      logError(e);\n      // we want to pass on the error, just in case.\n      throw e;\n    }\n  };\n}\n","export function mergeDeep(target: any, ...sources: any): any {\n  const output = {\n    ...target,\n  };\n  sources.forEach((source: any) => {\n    if (isObject(target) && isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, { [key]: source[key] });\n          } else {\n            output[key] = mergeDeep(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, { [key]: source[key] });\n        }\n      });\n    }\n  });\n  return output;\n}\n\nfunction isObject(item: any): boolean {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n","import {\n  defaultFieldResolver,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\n\nimport { mergeDeep } from '../utils/mergeDeep';\n\nimport { IExecutableSchemaDefinition, ILogger } from '../Interfaces';\nimport { SchemaDirectiveVisitor, forEachField } from '../utils/index';\nimport { addResolversToSchema } from '../addResolvers/addResolversToSchema';\n\nimport { attachDirectiveResolvers } from './attachDirectiveResolvers';\nimport { assertResolversPresent } from './assertResolversPresent';\nimport { addSchemaLevelResolver } from './addSchemaLevelResolver';\nimport { buildSchemaFromTypeDefinitions } from './buildSchemaFromTypeDefinitions';\nimport { decorateWithLogger } from './decorateWithLogger';\n\nexport function makeExecutableSchema<TContext = any>({\n  typeDefs,\n  resolvers = {},\n  logger,\n  allowUndefinedInResolve = true,\n  resolverValidationOptions = {},\n  directiveResolvers,\n  schemaDirectives,\n  parseOptions = {},\n  inheritResolversFromInterfaces = false,\n}: IExecutableSchemaDefinition<TContext>) {\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n\n  // We allow passing in an array of resolver maps, in which case we merge them\n  const resolverMap: any = Array.isArray(resolvers)\n    ? resolvers\n        .filter((resolverObj) => typeof resolverObj === 'object')\n        .reduce(mergeDeep, {})\n    : resolvers;\n\n  // Arguments are now validated and cleaned up\n\n  const schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n\n  addResolversToSchema({\n    schema,\n    resolvers: resolverMap,\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n  });\n\n  assertResolversPresent(schema, resolverValidationOptions);\n\n  if (!allowUndefinedInResolve) {\n    addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger != null) {\n    addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    addSchemaLevelResolver(\n      schema,\n      resolvers['__schema'] as GraphQLFieldResolver<any, any>,\n    );\n  }\n\n  if (directiveResolvers != null) {\n    attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return schema;\n}\n\nfunction decorateToCatchUndefined(\n  fn: GraphQLFieldResolver<any, any>,\n  hint: string,\n): GraphQLFieldResolver<any, any> {\n  const resolve = fn == null ? defaultFieldResolver : fn;\n  return (root, args, ctx, info) => {\n    const result = resolve(root, args, ctx, info);\n    if (typeof result === 'undefined') {\n      throw new Error(`Resolver for \"${hint}\" returned undefined`);\n    }\n    return result;\n  };\n}\n\nexport function addCatchUndefinedToSchema(schema: GraphQLSchema): void {\n  forEachField(schema, (field, typeName, fieldName) => {\n    const errorHint = `${typeName}.${fieldName}`;\n    field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n  });\n}\n\nexport function addErrorLoggingToSchema(\n  schema: GraphQLSchema,\n  logger?: ILogger,\n): void {\n  if (!logger) {\n    throw new Error('Must provide a logger');\n  }\n  if (typeof logger.log !== 'function') {\n    throw new Error('Logger.log must be a function');\n  }\n  forEachField(schema, (field, typeName, fieldName) => {\n    const errorHint = `${typeName}.${fieldName}`;\n    field.resolve = decorateWithLogger(field.resolve, logger, errorHint);\n  });\n}\n","import {\n  graphql,\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLList,\n  GraphQLType,\n  GraphQLField,\n  GraphQLResolveInfo,\n  getNullableType,\n  getNamedType,\n  GraphQLNamedType,\n  GraphQLFieldResolver,\n  GraphQLNullableType,\n  isSchema,\n  isObjectType,\n  isUnionType,\n  isInterfaceType,\n  isListType,\n  isEnumType,\n  isAbstractType,\n} from 'graphql';\n\nimport { buildSchemaFromTypeDefinitions } from '../generate/index';\nimport { forEachField } from '../utils/index';\n\nimport {\n  IMocks,\n  IMockServer,\n  IMockOptions,\n  IMockFn,\n  IMockTypeFn,\n  ITypeDefinitions,\n} from '../Interfaces';\n\n/**\n * This function wraps addMocksToSchema for more convenience\n */\nexport function mockServer(\n  schema: GraphQLSchema | ITypeDefinitions,\n  mocks: IMocks,\n  preserveResolvers: boolean = false,\n): IMockServer {\n  let mySchema: GraphQLSchema;\n  if (!isSchema(schema)) {\n    // TODO: provide useful error messages here if this fails\n    mySchema = buildSchemaFromTypeDefinitions(schema);\n  } else {\n    mySchema = schema;\n  }\n\n  addMocksToSchema({ schema: mySchema, mocks, preserveResolvers });\n\n  return { query: (query, vars) => graphql(mySchema, query, {}, {}, vars) };\n}\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    // eslint-disable-next-line eqeqeq\n    const v = c == 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nconst defaultMockMap: Map<string, IMockFn> = new Map();\ndefaultMockMap.set('Int', () => Math.round(Math.random() * 200) - 100);\ndefaultMockMap.set('Float', () => Math.random() * 200 - 100);\ndefaultMockMap.set('String', () => 'Hello World');\ndefaultMockMap.set('Boolean', () => Math.random() > 0.5);\ndefaultMockMap.set('ID', () => uuidv4());\n\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nexport function addMocksToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false,\n}: IMockOptions): void {\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n  if (!isSchema(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n  if (!isObject(mocks)) {\n    throw new Error('mocks must be of type Object');\n  }\n\n  // use Map internally, because that API is nicer.\n  const mockFunctionMap: Map<string, IMockFn> = new Map();\n  Object.keys(mocks).forEach((typeName) => {\n    mockFunctionMap.set(typeName, mocks[typeName]);\n  });\n\n  mockFunctionMap.forEach((mockFunction, mockTypeName) => {\n    if (typeof mockFunction !== 'function') {\n      throw new Error(`mockFunctionMap[${mockTypeName}] must be a function`);\n    }\n  });\n\n  const mockType = function (\n    type: GraphQLType,\n    _typeName?: string,\n    fieldName?: string,\n  ): GraphQLFieldResolver<any, any> {\n    // order of precendence for mocking:\n    // 1. if the object passed in already has fieldName, just use that\n    // --> if it's a function, that becomes your resolver\n    // --> if it's a value, the mock resolver will return that\n    // 2. if the nullableType is a list, recurse\n    // 2. if there's a mock defined for this typeName, that will be used\n    // 3. if there's no mock defined, use the default mocks for this type\n    return (\n      root: any,\n      args: Record<string, any>,\n      context: any,\n      info: GraphQLResolveInfo,\n    ): any => {\n      // nullability doesn't matter for the purpose of mocking.\n      const fieldType = getNullableType(type) as GraphQLNullableType;\n      const namedFieldType = getNamedType(fieldType);\n\n      if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n        let result: any;\n\n        // if we're here, the field is already defined\n        if (typeof root[fieldName] === 'function') {\n          result = root[fieldName](root, args, context, info);\n          if (isMockList(result)) {\n            result = result.mock(\n              root,\n              args,\n              context,\n              info,\n              fieldType as GraphQLList<any>,\n              mockType,\n            );\n          }\n        } else {\n          result = root[fieldName];\n        }\n\n        // Now we merge the result with the default mock for this type.\n        // This allows overriding defaults while writing very little code.\n        if (mockFunctionMap.has(namedFieldType.name)) {\n          const mock = mockFunctionMap.get(namedFieldType.name);\n\n          result = mergeMocks(\n            mock.bind(null, root, args, context, info),\n            result,\n          );\n        }\n        return result;\n      }\n\n      if (isListType(fieldType)) {\n        return [\n          mockType(fieldType.ofType)(root, args, context, info),\n          mockType(fieldType.ofType)(root, args, context, info),\n        ];\n      }\n      if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n        // the object passed doesn't have this field, so we apply the default mock\n        const mock = mockFunctionMap.get(fieldType.name);\n        return mock(root, args, context, info);\n      }\n      if (isObjectType(fieldType)) {\n        // objects don't return actual data, we only need to mock scalars!\n        return {};\n      }\n      // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n      // otherwise randomly pick a type from all implementation types\n      if (isAbstractType(fieldType)) {\n        let implementationType;\n        let interfaceMockObj: any = {};\n        if (mockFunctionMap.has(fieldType.name)) {\n          const mock = mockFunctionMap.get(fieldType.name);\n          interfaceMockObj = mock(root, args, context, info);\n          if (!interfaceMockObj || !interfaceMockObj.__typename) {\n            return Error(`Please return a __typename in \"${fieldType.name}\"`);\n          }\n          implementationType = schema.getType(interfaceMockObj.__typename);\n        } else {\n          const possibleTypes = schema.getPossibleTypes(fieldType);\n          implementationType = getRandomElement(possibleTypes);\n        }\n        return {\n          __typename: implementationType,\n          ...interfaceMockObj,\n          ...mockType(implementationType)(root, args, context, info),\n        };\n      }\n\n      if (isEnumType(fieldType)) {\n        return getRandomElement(fieldType.getValues()).value;\n      }\n\n      if (defaultMockMap.has(fieldType.name)) {\n        const defaultMock = defaultMockMap.get(fieldType.name);\n        return defaultMock(root, args, context, info);\n      }\n\n      // if we get to here, we don't have a value, and we don't have a mock for this type,\n      // we could return undefined, but that would be hard to debug, so we throw instead.\n      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n      return Error(`No mock defined for type \"${fieldType.name}\"`);\n    };\n  };\n\n  forEachField(\n    schema,\n    (field: GraphQLField<any, any>, typeName: string, fieldName: string) => {\n      assignResolveType(field.type, preserveResolvers);\n      let mockResolver: GraphQLFieldResolver<any, any> = mockType(\n        field.type,\n        typeName,\n        fieldName,\n      );\n\n      // we have to handle the root mutation and root query types differently,\n      // because no resolver is called at the root.\n      const queryType = schema.getQueryType();\n      const isOnQueryType = queryType != null && queryType.name === typeName;\n\n      const mutationType = schema.getMutationType();\n      const isOnMutationType =\n        mutationType != null && mutationType.name === typeName;\n\n      if (isOnQueryType || isOnMutationType) {\n        if (mockFunctionMap.has(typeName)) {\n          const rootMock = mockFunctionMap.get(typeName);\n          // XXX: BUG in here, need to provide proper signature for rootMock.\n          if (\n            typeof rootMock(undefined, {}, {}, {} as any)[fieldName] ===\n            'function'\n          ) {\n            mockResolver = (\n              root: any,\n              args: Record<string, any>,\n              context: any,\n              info: GraphQLResolveInfo,\n            ) => {\n              const updatedRoot = root ?? {}; // TODO: should we clone instead?\n              updatedRoot[fieldName] = rootMock(root, args, context, info)[\n                fieldName\n              ];\n              // XXX this is a bit of a hack to still use mockType, which\n              // lets you mock lists etc. as well\n              // otherwise we could just set field.resolve to rootMock()[fieldName]\n              // it's like pretending there was a resolver that ran before\n              // the root resolver.\n              return mockType(field.type, typeName, fieldName)(\n                updatedRoot,\n                args,\n                context,\n                info,\n              );\n            };\n          }\n        }\n      }\n      if (!preserveResolvers || !field.resolve) {\n        field.resolve = mockResolver;\n      } else {\n        const oldResolver = field.resolve;\n        field.resolve = (\n          rootObject: any,\n          args: Record<string, any>,\n          context: any,\n          info: GraphQLResolveInfo,\n        ) =>\n          Promise.all([\n            mockResolver(rootObject, args, context, info),\n            oldResolver(rootObject, args, context, info),\n          ]).then((values) => {\n            const [mockedValue, resolvedValue] = values;\n\n            // In case we couldn't mock\n            if (mockedValue instanceof Error) {\n              // only if value was not resolved, populate the error.\n              if (undefined === resolvedValue) {\n                throw mockedValue;\n              }\n              return resolvedValue;\n            }\n\n            if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n              return undefined !== resolvedValue ? resolvedValue : mockedValue;\n            }\n\n            if (isObject(mockedValue) && isObject(resolvedValue)) {\n              // Object.assign() won't do here, as we need to all properties, including\n              // the non-enumerable ones and defined using Object.defineProperty\n              const emptyObject = Object.create(\n                Object.getPrototypeOf(resolvedValue),\n              );\n              return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n            }\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          });\n      }\n    },\n  );\n}\n\nfunction isObject(thing: any) {\n  return thing === Object(thing) && !Array.isArray(thing);\n}\n\n// returns a random element from that ary\nfunction getRandomElement(ary: ReadonlyArray<any>) {\n  const sample = Math.floor(Math.random() * ary.length);\n  return ary[sample];\n}\n\nfunction mergeObjects(a: Record<string, any>, b: Record<string, any>) {\n  return Object.assign(a, b);\n}\n\nfunction copyOwnPropsIfNotPresent(\n  target: Record<string, any>,\n  source: Record<string, any>,\n) {\n  Object.getOwnPropertyNames(source).forEach((prop) => {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n      Object.defineProperty(\n        target,\n        prop,\n        propertyDescriptor == null ? {} : propertyDescriptor,\n      );\n    }\n  });\n}\n\nfunction copyOwnProps(\n  target: Record<string, any>,\n  ...sources: Array<Record<string, any>>\n) {\n  sources.forEach((source) => {\n    let chain = source;\n    while (chain != null) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  });\n  return target;\n}\n\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction: () => any, customMock: any): any {\n  if (Array.isArray(customMock)) {\n    return customMock.map((el: any) => mergeMocks(genericMockFunction, el));\n  }\n  if (isObject(customMock)) {\n    return mergeObjects(genericMockFunction(), customMock);\n  }\n  return customMock;\n}\n\nfunction getResolveType(namedFieldType: GraphQLNamedType) {\n  if (isAbstractType(namedFieldType)) {\n    return namedFieldType.resolveType;\n  }\n}\n\nfunction assignResolveType(type: GraphQLType, preserveResolvers: boolean) {\n  const fieldType = getNullableType(type) as GraphQLNullableType;\n  const namedFieldType = getNamedType(fieldType);\n\n  const oldResolveType = getResolveType(namedFieldType);\n  if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n    return;\n  }\n\n  if (isInterfaceType(namedFieldType) || isUnionType(namedFieldType)) {\n    // the default `resolveType` always returns null. We add a fallback\n    // resolution that works with how unions and interface are mocked\n    namedFieldType.resolveType = (\n      data: any,\n      _context: any,\n      info: GraphQLResolveInfo,\n    ) => info.schema.getType(data.__typename) as GraphQLObjectType;\n  }\n}\n\nexport function isMockList(obj: any): obj is MockList {\n  if (\n    typeof obj?.len === 'number' ||\n    (Array.isArray(obj?.len) && typeof obj?.len[0] === 'number')\n  ) {\n    if (\n      typeof obj.wrappedFunction === 'undefined' ||\n      typeof obj.wrappedFunction === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport class MockList {\n  private readonly len: number | Array<number>;\n  private readonly wrappedFunction: GraphQLFieldResolver<any, any> | undefined;\n\n  // wrappedFunction can return another MockList or a value\n  constructor(\n    len: number | Array<number>,\n    wrappedFunction?: GraphQLFieldResolver<any, any>,\n  ) {\n    this.len = len;\n    if (typeof wrappedFunction !== 'undefined') {\n      if (typeof wrappedFunction !== 'function') {\n        throw new Error(\n          'Second argument to MockList must be a function or undefined',\n        );\n      }\n      this.wrappedFunction = wrappedFunction;\n    }\n  }\n\n  public mock(\n    root: any,\n    args: Record<string, any>,\n    context: any,\n    info: GraphQLResolveInfo,\n    fieldType: GraphQLList<any>,\n    mockTypeFunc: IMockTypeFn,\n  ) {\n    let arr: Array<any>;\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        const res = this.wrappedFunction(root, args, context, info);\n        if (isMockList(res)) {\n          const nullableType = getNullableType(fieldType.ofType) as GraphQLList<\n            any\n          >;\n          arr[i] = res.mock(\n            root,\n            args,\n            context,\n            info,\n            nullableType,\n            mockTypeFunc,\n          );\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n      }\n    }\n    return arr;\n  }\n\n  private randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  }\n}\n\n// retain addMockFunctionsToSchema for backwards compatibility\n\nexport function addMockFunctionsToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false,\n}: IMockOptions): void {\n  addMocksToSchema({ schema, mocks, preserveResolvers });\n}\n","import { GraphQLScalarType, GraphQLError } from 'graphql';\n\nconst GraphQLUpload = new GraphQLScalarType({\n  name: 'Upload',\n  description: 'The `Upload` scalar type represents a file upload.',\n  parseValue: (value) => {\n    if (value != null && value.promise instanceof Promise) {\n      // graphql-upload v10\n      return value.promise;\n    } else if (value instanceof Promise) {\n      // graphql-upload v9\n      return value;\n    }\n    throw new GraphQLError('Upload value invalid.');\n  },\n  // serialization requires to support schema stitching\n  serialize: (value) => value,\n  parseLiteral: (ast) => {\n    throw new GraphQLError('Upload literal unsupported.', ast);\n  },\n});\n\nexport { GraphQLUpload };\n"],"names":["VisitSchemaKind","MapperKind","GraphQLSchema","isObjectType","isInputType","isInterfaceType","isUnionType","isEnumType","isScalarType","isNamedType","isDirective","GraphQLDirective","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","isInputObjectType","GraphQLInputObjectType","GraphQLEnumType","isSpecifiedScalarType","GraphQLScalarType","isListType","GraphQLList","isNonNullType","GraphQLNonNull","GraphQLInt","GraphQLFloat","GraphQLString","GraphQLBoolean","GraphQLID","pruneTypes","isLeafType","Kind","isSchema","getTypeSpecifiers","GraphQLError","valueFromAST","print","getNamedType","getNullableType","isAbstractType","defaultFieldResolver","parse","buildASTSchema","extendSchema","graphql","isObject"],"mappings":"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"}