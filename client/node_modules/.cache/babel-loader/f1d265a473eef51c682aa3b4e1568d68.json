{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar invariant = require('invariant');\n\nvar _require = require('../util/RelayConcreteNode'),\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getStorageKey = _require3.getStorageKey,\n    getModuleComponentKey = _require3.getModuleComponentKey;\n\nvar _require4 = require('./ResolverFragments'),\n    withResolverContext = _require4.withResolverContext;\n\nvar _require5 = require('./TypeID'),\n    generateTypeID = _require5.generateTypeID;\n\nfunction read(recordSource, selector) {\n  var reader = new RelayReader(recordSource, selector);\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector) {\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null && RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields\n    };\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._isMissingData = true;\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._selector.node.name;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: []\n          };\n        }\n\n        this._missingRequiredFields.fields.push({\n          path: fieldPath,\n          owner: owner\n        });\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          !RelayFeatureFlags.ENABLE_REQUIRED_DIRECTIVES ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Encountered a `@required` directive at path \"%s\" in `%s` without the `ENABLE_REQUIRED_DIRECTIVES` feature flag enabled.', selection.path, this._selector.node.name) : invariant(false) : void 0;\n\n          var fieldValue = this._readRequiredField(selection, record, data);\n\n          if (fieldValue == null) {\n            var action = selection.action;\n\n            if (action !== 'NONE') {\n              this._maybeReportUnexpectedNull(selection.path, action, record);\n            } // We are going to throw, or our parent is going to get nulled out.\n            // Either way, sibling values are going to be ignored, so we can\n            // bail early here as an optimization.\n\n\n            return false;\n          }\n\n          break;\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = this._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n                if (!_hasExpectedData) {\n                  return false;\n                }\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._isMissingData = true;\n              }\n            } else {\n              // legacy behavior for abstract refinements: always read even\n              // if the type doesn't conform and don't reset isMissingData\n              this._traverseSelections(selection.selections, record, data);\n            }\n\n            break;\n          }\n\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);\n\n            this._isMissingData = isMissingData;\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData3) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(selection, record, data) {\n    var _this = this;\n\n    var name = selection.name,\n        alias = selection.alias,\n        resolverModule = selection.resolverModule,\n        fragment = selection.fragment;\n    var key = {\n      __id: RelayModernRecord.getDataID(record),\n      __fragmentOwner: this._owner,\n      __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, {})\n    };\n    var resolverContext = {\n      getDataForResolverFragment: function getDataForResolverFragment(singularReaderSelector) {\n        var _resolverFragmentData;\n\n        var resolverFragmentData = {};\n\n        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);\n\n        var answer = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];\n        !(typeof answer === 'object' && answer !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Expected reader data to contain a __fragments property with a property for the fragment named \".concat(fragment.name, \", but it is missing.\")) : invariant(false) : void 0;\n        return answer;\n      }\n    };\n    var resolverResult = withResolverContext(resolverContext, function () {\n      return (// $FlowFixMe[prop-missing] - resolver module's type signature is a lie\n        resolverModule(key)\n      );\n    });\n    data[alias !== null && alias !== void 0 ? alias : name] = resolverResult;\n    return resolverResult;\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias;\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._isMissingData = true;\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this2 = this;\n\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this2._isMissingData = true;\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: null\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n\n    if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n    }\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/RelayReader.js"],"names":["_interopRequireDefault","require","_defineProperty2","RelayFeatureFlags","RelayModernRecord","invariant","_require","CLIENT_EXTENSION","CONDITION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_DATA_FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","MODULE_IMPORT","REQUIRED_FIELD","RELAY_RESOLVER","SCALAR_FIELD","STREAM","_require2","getReactFlightClientResponse","_require3","FRAGMENTS_KEY","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","ID_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","MODULE_COMPONENT_KEY","ROOT_ID","getArgumentValues","getStorageKey","getModuleComponentKey","_require4","withResolverContext","_require5","generateTypeID","read","recordSource","selector","reader","RelayReader","_isMissingData","_isWithinUnmatchedTypeRefinement","_missingRequiredFields","_owner","owner","_recordSource","_seenRecords","Set","_selector","_variables","variables","_proto","prototype","_this$_selector","node","dataID","isWithinUnmatchedTypeRefinement","abstractKey","record","get","isDataExpectedToBePresent","recordType","getType","type","ENABLE_PRECISE_TYPE_REFINEMENT","_recordType","typeID","typeRecord","implementsInterface","getValue","data","_traverse","isMissingData","seenRecords","missingRequiredFields","prevData","add","undefined","hadRequiredData","_traverseSelections","selections","_getVariableValue","name","hasOwnProperty","process","env","NODE_ENV","_maybeReportUnexpectedNull","fieldPath","action","_this$_missingRequire","field","path","fields","push","i","length","selection","kind","ENABLE_REQUIRED_DIRECTIVES","fieldValue","_readRequiredField","_readScalar","plural","_readPluralLink","_readLink","conditionValue","condition","passingValue","hasExpectedData","typeName","_hasExpectedData","parentIsMissingData","parentIsWithinUnmatchedTypeRefinement","_typeName","ENABLE_RELAY_RESOLVERS","Error","_readResolverField","_createFragmentPointer","_readModuleImport","_createInlineDataOrResolverFragmentPointer","_hasExpectedData2","_hasExpectedData3","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_readFlightField","_this","alias","resolverModule","fragment","key","__id","getDataID","__fragmentOwner","__fragments","resolverContext","getDataForResolverFragment","singularReaderSelector","_resolverFragmentData","resolverFragmentData","answer","concat","resolverResult","_field$alias","applicationName","storageKey","reactFlightClientResponseRecordID","getLinkedRecordID","reactFlightClientResponseRecord","clientResponse","_field$alias2","value","_field$alias3","linkedID","_this2","_field$alias4","linkedIDs","getLinkedRecordIDs","Array","isArray","linkedArray","forEach","nextIndex","prevItem","moduleImport","componentKey","documentName","component","fragmentName","args","fragmentPropName","fragmentSpread","fragmentPointers","fragmentSpreadOrFragment","inlineData","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar invariant = require('invariant');\n\nvar _require = require('../util/RelayConcreteNode'),\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getStorageKey = _require3.getStorageKey,\n    getModuleComponentKey = _require3.getModuleComponentKey;\n\nvar _require4 = require('./ResolverFragments'),\n    withResolverContext = _require4.withResolverContext;\n\nvar _require5 = require('./TypeID'),\n    generateTypeID = _require5.generateTypeID;\n\nfunction read(recordSource, selector) {\n  var reader = new RelayReader(recordSource, selector);\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector) {\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null && RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields\n    };\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._isMissingData = true;\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._selector.node.name;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: []\n          };\n        }\n\n        this._missingRequiredFields.fields.push({\n          path: fieldPath,\n          owner: owner\n        });\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          !RelayFeatureFlags.ENABLE_REQUIRED_DIRECTIVES ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Encountered a `@required` directive at path \"%s\" in `%s` without the `ENABLE_REQUIRED_DIRECTIVES` feature flag enabled.', selection.path, this._selector.node.name) : invariant(false) : void 0;\n\n          var fieldValue = this._readRequiredField(selection, record, data);\n\n          if (fieldValue == null) {\n            var action = selection.action;\n\n            if (action !== 'NONE') {\n              this._maybeReportUnexpectedNull(selection.path, action, record);\n            } // We are going to throw, or our parent is going to get nulled out.\n            // Either way, sibling values are going to be ignored, so we can\n            // bail early here as an optimization.\n\n\n            return false;\n          }\n\n          break;\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = this._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n                if (!_hasExpectedData) {\n                  return false;\n                }\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._isMissingData = true;\n              }\n            } else {\n              // legacy behavior for abstract refinements: always read even\n              // if the type doesn't conform and don't reset isMissingData\n              this._traverseSelections(selection.selections, record, data);\n            }\n\n            break;\n          }\n\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);\n\n            this._isMissingData = isMissingData;\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData3) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(selection, record, data) {\n    var _this = this;\n\n    var name = selection.name,\n        alias = selection.alias,\n        resolverModule = selection.resolverModule,\n        fragment = selection.fragment;\n    var key = {\n      __id: RelayModernRecord.getDataID(record),\n      __fragmentOwner: this._owner,\n      __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, {})\n    };\n    var resolverContext = {\n      getDataForResolverFragment: function getDataForResolverFragment(singularReaderSelector) {\n        var _resolverFragmentData;\n\n        var resolverFragmentData = {};\n\n        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);\n\n        var answer = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];\n        !(typeof answer === 'object' && answer !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Expected reader data to contain a __fragments property with a property for the fragment named \".concat(fragment.name, \", but it is missing.\")) : invariant(false) : void 0;\n        return answer;\n      }\n    };\n    var resolverResult = withResolverContext(resolverContext, function () {\n      return (// $FlowFixMe[prop-missing] - resolver module's type signature is a lie\n        resolverModule(key)\n      );\n    });\n    data[alias !== null && alias !== void 0 ? alias : name] = resolverResult;\n    return resolverResult;\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias;\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._isMissingData = true;\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this2 = this;\n\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this2._isMissingData = true;\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: null\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n\n    if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n    }\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};"]},"metadata":{},"sourceType":"script"}