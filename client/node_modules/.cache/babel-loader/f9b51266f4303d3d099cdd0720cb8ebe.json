{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar getOperation = require('../util/getOperation');\n\nvar invariant = require('invariant');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayRecordState'),\n    EXISTENT = _require2.EXISTENT,\n    UNKNOWN = _require2.UNKNOWN;\n\nvar _require3 = require('./TypeID'),\n    generateTypeID = _require3.generateTypeID;\n\nvar CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_COMPONENT = RelayConcreteNode.CLIENT_COMPONENT,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FLIGHT_FIELD = RelayConcreteNode.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar ROOT_ID = RelayStoreUtils.ROOT_ID,\n    getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(source, target, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(source, target, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(source, target, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n    var mutator = new RelayRecordSourceMutator(source, target);\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = new RelayRecordSourceProxy(mutator, getDataID);\n    this._recordWasMissing = false;\n    this._source = source;\n    this._variables = variables;\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = _this2._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var recordType = _this2._mutator.getType(dataID);\n\n              !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n              var typeID = generateTypeID(recordType);\n\n              var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n              if (implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            } else {\n              // legacy behavior for abstract refinements: always check even\n              // if the type doesn't conform\n              _this2._traverseSelections(selection.selections, dataID);\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n        // $FlowFixMe[incompatible-type]\n\n        case FRAGMENT_SPREAD:\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n            var _abstractKey = selection.abstractKey;\n\n            var _recordType = _this2._mutator.getType(dataID);\n\n            !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n            var _typeID = generateTypeID(_recordType);\n\n            var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n            if (_implementsInterface == null) {\n              // unsure if the type implements the interface: data is\n              // missing\n              _this2._handleMissing();\n            } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n          }\n\n          break;\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            _this2._checkFlightField(selection, dataID);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case CLIENT_COMPONENT:\n          if (_this2._shouldProcessClientComponents === false) {\n            break;\n          }\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var normalizationRootNode = operationLoader.get(operationReference);\n\n    if (normalizationRootNode != null) {\n      var operation = getOperation(normalizationRootNode);\n\n      this._traverse(operation, dataID);\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  _proto._checkFlightField = function _checkFlightField(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID == null) {\n      if (linkedID === undefined) {\n        this._handleMissing();\n\n        return;\n      }\n\n      return;\n    }\n\n    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);\n\n    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);\n\n    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {\n      this._handleMissing();\n\n      return;\n    }\n\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : invariant(false) : void 0; // In Flight, the variables that are in scope for reachable executable\n    // definitions aren't the same as what's in scope for the outer query.\n\n    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(reachableExecutableDefinitions),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var definition = _step4.value;\n        this._variables = definition.variables;\n        var normalizationRootNode = operationLoader.get(definition.module);\n\n        if (normalizationRootNode != null) {\n          var operation = getOperation(normalizationRootNode);\n\n          this._traverseSelections(operation.selections, ROOT_ID);\n        } else {\n          // If the fragment is not available, we assume that the data cannot have\n          // been processed yet and must therefore be missing.\n          this._handleMissing();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    this._variables = prevVariables;\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/DataChecker.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","RelayConcreteNode","RelayFeatureFlags","RelayModernRecord","RelayRecordSourceMutator","RelayRecordSourceProxy","RelayStoreReactFlightUtils","RelayStoreUtils","cloneRelayHandleSourceField","cloneRelayScalarHandleSourceField","getOperation","invariant","_require","isClientID","_require2","EXISTENT","UNKNOWN","_require3","generateTypeID","CONDITION","CLIENT_COMPONENT","CLIENT_EXTENSION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","LINKED_HANDLE","MODULE_IMPORT","SCALAR_FIELD","SCALAR_HANDLE","STREAM","TYPE_DISCRIMINATOR","ROOT_ID","getModuleOperationKey","getStorageKey","getArgumentValues","check","source","target","selector","handlers","operationLoader","getDataID","shouldProcessClientComponents","dataID","node","variables","checker","DataChecker","mutator","_mostRecentlyInvalidatedAt","_handlers","_mutator","_operationLoader","_recordSourceProxy","_recordWasMissing","_source","_variables","_shouldProcessClientComponents","_proto","prototype","_traverse","status","mostRecentlyInvalidatedAt","_getVariableValue","name","hasOwnProperty","process","env","NODE_ENV","_handleMissing","_getDataForHandlers","field","args","record","get","_handleMissingScalarField","alias","undefined","_this$_getDataForHand","_iterator","_step","s","n","done","handler","value","kind","newValue","handle","err","e","f","_handleMissingLinkField","_this$_getDataForHand2","_iterator2","_step2","getStatus","_handleMissingPluralLinkField","_this","_this$_getDataForHand3","_iterator3","_step3","allItemsKnown","every","linkedID","invalidatedAt","getInvalidationEpoch","Math","max","_traverseSelections","selections","_this2","forEach","selection","_checkScalar","plural","_checkPluralLink","_checkLink","conditionValue","condition","passingValue","abstractKey","typeName","getType","type","ENABLE_PRECISE_TYPE_REFINEMENT","recordType","typeID","implementsInterface","getValue","handleField","_handleField","_checkModuleImport","fragment","recordWasMissing","_abstractKey","_recordType","_typeID","_implementsInterface","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_checkFlightField","Error","moduleImport","operationKey","documentName","operationReference","normalizationRootNode","operation","storageKey","fieldValue","setValue","getLinkedRecordID","setLinkedRecordID","_this3","linkedIDs","getLinkedRecordIDs","setLinkedRecordIDs","tree","REACT_FLIGHT_TREE_STORAGE_KEY","reachableExecutableDefinitions","REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY","Array","isArray","prevVariables","_iterator4","_step4","definition","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar getOperation = require('../util/getOperation');\n\nvar invariant = require('invariant');\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayRecordState'),\n    EXISTENT = _require2.EXISTENT,\n    UNKNOWN = _require2.UNKNOWN;\n\nvar _require3 = require('./TypeID'),\n    generateTypeID = _require3.generateTypeID;\n\nvar CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_COMPONENT = RelayConcreteNode.CLIENT_COMPONENT,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FLIGHT_FIELD = RelayConcreteNode.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar ROOT_ID = RelayStoreUtils.ROOT_ID,\n    getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(source, target, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(source, target, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(source, target, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents) {\n    var mutator = new RelayRecordSourceMutator(source, target);\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = new RelayRecordSourceProxy(mutator, getDataID);\n    this._recordWasMissing = false;\n    this._source = source;\n    this._variables = variables;\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = _this2._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var recordType = _this2._mutator.getType(dataID);\n\n              !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n              var typeID = generateTypeID(recordType);\n\n              var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n              if (implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            } else {\n              // legacy behavior for abstract refinements: always check even\n              // if the type doesn't conform\n              _this2._traverseSelections(selection.selections, dataID);\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n        // $FlowFixMe[incompatible-type]\n\n        case FRAGMENT_SPREAD:\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n            var _abstractKey = selection.abstractKey;\n\n            var _recordType = _this2._mutator.getType(dataID);\n\n            !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n            var _typeID = generateTypeID(_recordType);\n\n            var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n            if (_implementsInterface == null) {\n              // unsure if the type implements the interface: data is\n              // missing\n              _this2._handleMissing();\n            } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n          }\n\n          break;\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            _this2._checkFlightField(selection, dataID);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case CLIENT_COMPONENT:\n          if (_this2._shouldProcessClientComponents === false) {\n            break;\n          }\n\n          _this2._traverseSelections(selection.fragment.selections, dataID);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var normalizationRootNode = operationLoader.get(operationReference);\n\n    if (normalizationRootNode != null) {\n      var operation = getOperation(normalizationRootNode);\n\n      this._traverse(operation, dataID);\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  _proto._checkFlightField = function _checkFlightField(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID == null) {\n      if (linkedID === undefined) {\n        this._handleMissing();\n\n        return;\n      }\n\n      return;\n    }\n\n    var tree = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_TREE_STORAGE_KEY);\n\n    var reachableExecutableDefinitions = this._mutator.getValue(linkedID, RelayStoreReactFlightUtils.REACT_FLIGHT_EXECUTABLE_DEFINITIONS_STORAGE_KEY);\n\n    if (tree == null || !Array.isArray(reachableExecutableDefinitions)) {\n      this._handleMissing();\n\n      return;\n    }\n\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using ' + 'React Flight.') : invariant(false) : void 0; // In Flight, the variables that are in scope for reachable executable\n    // definitions aren't the same as what's in scope for the outer query.\n\n    var prevVariables = this._variables; // $FlowFixMe[incompatible-cast]\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(reachableExecutableDefinitions),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var definition = _step4.value;\n        this._variables = definition.variables;\n        var normalizationRootNode = operationLoader.get(definition.module);\n\n        if (normalizationRootNode != null) {\n          var operation = getOperation(normalizationRootNode);\n\n          this._traverseSelections(operation.selections, ROOT_ID);\n        } else {\n          // If the fragment is not available, we assume that the data cannot have\n          // been processed yet and must therefore be missing.\n          this._handleMissing();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    this._variables = prevVariables;\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};"]},"metadata":{},"sourceType":"script"}