{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReader = require('./RelayReader');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayStoreSubscriptionsUsingMapByID = /*#__PURE__*/function () {\n  function RelayStoreSubscriptionsUsingMapByID(log) {\n    this._notifiedRevision = 0;\n    this._snapshotRevision = 0;\n    this._subscriptionsByDataId = new Map();\n    this._staleSubscriptions = new Set();\n    this.__log = log;\n  }\n\n  var _proto = RelayStoreSubscriptionsUsingMapByID.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      notifiedRevision: this._notifiedRevision,\n      snapshotRevision: this._snapshotRevision,\n      snapshot: snapshot\n    };\n\n    var dispose = function dispose() {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(snapshot.seenRecords),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dataId = _step.value;\n\n          var subscriptionsForDataId = _this._subscriptionsByDataId.get(dataId);\n\n          if (subscriptionsForDataId != null) {\n            subscriptionsForDataId[\"delete\"](subscription);\n\n            if (subscriptionsForDataId.size === 0) {\n              _this._subscriptionsByDataId[\"delete\"](dataId);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(snapshot.seenRecords),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var dataId = _step2.value;\n\n        var subscriptionsForDataId = this._subscriptionsByDataId.get(dataId);\n\n        if (subscriptionsForDataId != null) {\n          subscriptionsForDataId.add(subscription);\n        } else {\n          this._subscriptionsByDataId.set(dataId, new Set([subscription]));\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._snapshotRevision++;\n\n    this._subscriptionsByDataId.forEach(function (subscriptions) {\n      subscriptions.forEach(function (subscription) {\n        if (subscription.snapshotRevision === _this2._snapshotRevision) {\n          return;\n        }\n\n        subscription.snapshotRevision = _this2._snapshotRevision; // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n        // optimistic changes. Each subscription's `snapshot` represents what was *last\n        // published to the subscriber*, which notably may include previous optimistic\n        // updates. Therefore a subscription can be in any of the following states:\n        // - stale=true: This subscription was restored to a different value than\n        //   `snapshot`. That means this subscription has changes relative to its base,\n        //   but its base has changed (we just applied a final payload): recompute\n        //   a backup so that we can later restore to the state the subscription\n        //   should be in.\n        // - stale=false: This subscription was restored to the same value than\n        //   `snapshot`. That means this subscription does *not* have changes relative\n        //   to its base, so the current `snapshot` is valid to use as a backup.\n\n        if (!_this2._staleSubscriptions.has(subscription)) {\n          subscription.backup = subscription.snapshot;\n          return;\n        }\n\n        var snapshot = subscription.snapshot;\n        var backup = RelayReader.read(source, snapshot.selector);\n        var nextData = recycleNodesInto(snapshot.data, backup.data);\n        backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n        subscription.backup = backup;\n      });\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    var _this3 = this;\n\n    this._snapshotRevision++;\n\n    this._subscriptionsByDataId.forEach(function (subscriptions) {\n      subscriptions.forEach(function (subscription) {\n        if (subscription.snapshotRevision === _this3._snapshotRevision) {\n          return;\n        }\n\n        subscription.snapshotRevision = _this3._snapshotRevision;\n        var backup = subscription.backup;\n        subscription.backup = null;\n\n        if (backup) {\n          if (backup.data !== subscription.snapshot.data) {\n            _this3._staleSubscriptions.add(subscription);\n          }\n\n          var prevSeenRecords = subscription.snapshot.seenRecords;\n          subscription.snapshot = {\n            data: subscription.snapshot.data,\n            isMissingData: backup.isMissingData,\n            seenRecords: backup.seenRecords,\n            selector: backup.selector,\n            missingRequiredFields: backup.missingRequiredFields\n          };\n\n          _this3._updateSubscriptionsMap(subscription, prevSeenRecords);\n        } else {\n          _this3._staleSubscriptions.add(subscription);\n        }\n      });\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this4 = this;\n\n    this._notifiedRevision++;\n    updatedRecordIDs.forEach(function (updatedRecordId) {\n      var subcriptionsForDataId = _this4._subscriptionsByDataId.get(updatedRecordId);\n\n      if (subcriptionsForDataId == null) {\n        return;\n      }\n\n      subcriptionsForDataId.forEach(function (subscription) {\n        if (subscription.notifiedRevision === _this4._notifiedRevision) {\n          return;\n        }\n\n        var owner = _this4._updateSubscription(source, subscription, false, sourceOperation);\n\n        if (owner != null) {\n          updatedOwners.push(owner);\n        }\n      });\n    });\n\n    this._staleSubscriptions.forEach(function (subscription) {\n      if (subscription.notifiedRevision === _this4._notifiedRevision) {\n        return;\n      }\n\n      var owner = _this4._updateSubscription(source, subscription, true, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._staleSubscriptions.clear();\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * amarks it as not stale, and updates the subscription tracking for any\n   * any new ids observed in the latest data snapshot.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, stale, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot;\n    var nextSnapshot = stale && backup != null ? backup : RelayReader.read(source, snapshot.selector);\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    var prevSeenRecords = subscription.snapshot.seenRecords;\n    subscription.snapshot = nextSnapshot;\n    subscription.notifiedRevision = this._notifiedRevision;\n\n    this._updateSubscriptionsMap(subscription, prevSeenRecords);\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  }\n  /**\n   * Updates the Map that tracks subscriptions by id.\n   * Given an updated subscription and the records that where seen\n   * on the previous subscription snapshot, updates our tracking\n   * to track the subscription for the newly and no longer seen ids.\n   */\n  ;\n\n  _proto._updateSubscriptionsMap = function _updateSubscriptionsMap(subscription, prevSeenRecords) {\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(prevSeenRecords),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var dataId = _step3.value;\n\n        var subscriptionsForDataId = this._subscriptionsByDataId.get(dataId);\n\n        if (subscriptionsForDataId != null) {\n          subscriptionsForDataId[\"delete\"](subscription);\n\n          if (subscriptionsForDataId.size === 0) {\n            this._subscriptionsByDataId[\"delete\"](dataId);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(subscription.snapshot.seenRecords),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _dataId = _step4.value;\n\n        var _subscriptionsForDataId = this._subscriptionsByDataId.get(_dataId);\n\n        if (_subscriptionsForDataId != null) {\n          _subscriptionsForDataId.add(subscription);\n        } else {\n          this._subscriptionsByDataId.set(_dataId, new Set([subscription]));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  return RelayStoreSubscriptionsUsingMapByID;\n}();\n\nmodule.exports = RelayStoreSubscriptionsUsingMapByID;","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/RelayStoreSubscriptionsUsingMapByID.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","RelayFeatureFlags","RelayReader","deepFreeze","recycleNodesInto","RelayStoreSubscriptionsUsingMapByID","log","_notifiedRevision","_snapshotRevision","_subscriptionsByDataId","Map","_staleSubscriptions","Set","__log","_proto","prototype","subscribe","snapshot","callback","_this","subscription","backup","notifiedRevision","snapshotRevision","dispose","_iterator","seenRecords","_step","s","n","done","dataId","value","subscriptionsForDataId","get","size","err","e","f","_iterator2","_step2","add","set","snapshotSubscriptions","source","_this2","forEach","subscriptions","has","read","selector","nextData","data","restoreSubscriptions","_this3","prevSeenRecords","isMissingData","missingRequiredFields","_updateSubscriptionsMap","updateSubscriptions","updatedRecordIDs","updatedOwners","sourceOperation","_this4","updatedRecordId","subcriptionsForDataId","owner","_updateSubscription","push","clear","stale","nextSnapshot","process","env","NODE_ENV","ENABLE_NOTIFY_SUBSCRIPTION","name","_iterator3","_step3","_iterator4","_step4","_dataId","_subscriptionsForDataId","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReader = require('./RelayReader');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayStoreSubscriptionsUsingMapByID = /*#__PURE__*/function () {\n  function RelayStoreSubscriptionsUsingMapByID(log) {\n    this._notifiedRevision = 0;\n    this._snapshotRevision = 0;\n    this._subscriptionsByDataId = new Map();\n    this._staleSubscriptions = new Set();\n    this.__log = log;\n  }\n\n  var _proto = RelayStoreSubscriptionsUsingMapByID.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      notifiedRevision: this._notifiedRevision,\n      snapshotRevision: this._snapshotRevision,\n      snapshot: snapshot\n    };\n\n    var dispose = function dispose() {\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(snapshot.seenRecords),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dataId = _step.value;\n\n          var subscriptionsForDataId = _this._subscriptionsByDataId.get(dataId);\n\n          if (subscriptionsForDataId != null) {\n            subscriptionsForDataId[\"delete\"](subscription);\n\n            if (subscriptionsForDataId.size === 0) {\n              _this._subscriptionsByDataId[\"delete\"](dataId);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n\n    var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(snapshot.seenRecords),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var dataId = _step2.value;\n\n        var subscriptionsForDataId = this._subscriptionsByDataId.get(dataId);\n\n        if (subscriptionsForDataId != null) {\n          subscriptionsForDataId.add(subscription);\n        } else {\n          this._subscriptionsByDataId.set(dataId, new Set([subscription]));\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._snapshotRevision++;\n\n    this._subscriptionsByDataId.forEach(function (subscriptions) {\n      subscriptions.forEach(function (subscription) {\n        if (subscription.snapshotRevision === _this2._snapshotRevision) {\n          return;\n        }\n\n        subscription.snapshotRevision = _this2._snapshotRevision; // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n        // optimistic changes. Each subscription's `snapshot` represents what was *last\n        // published to the subscriber*, which notably may include previous optimistic\n        // updates. Therefore a subscription can be in any of the following states:\n        // - stale=true: This subscription was restored to a different value than\n        //   `snapshot`. That means this subscription has changes relative to its base,\n        //   but its base has changed (we just applied a final payload): recompute\n        //   a backup so that we can later restore to the state the subscription\n        //   should be in.\n        // - stale=false: This subscription was restored to the same value than\n        //   `snapshot`. That means this subscription does *not* have changes relative\n        //   to its base, so the current `snapshot` is valid to use as a backup.\n\n        if (!_this2._staleSubscriptions.has(subscription)) {\n          subscription.backup = subscription.snapshot;\n          return;\n        }\n\n        var snapshot = subscription.snapshot;\n        var backup = RelayReader.read(source, snapshot.selector);\n        var nextData = recycleNodesInto(snapshot.data, backup.data);\n        backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n        subscription.backup = backup;\n      });\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    var _this3 = this;\n\n    this._snapshotRevision++;\n\n    this._subscriptionsByDataId.forEach(function (subscriptions) {\n      subscriptions.forEach(function (subscription) {\n        if (subscription.snapshotRevision === _this3._snapshotRevision) {\n          return;\n        }\n\n        subscription.snapshotRevision = _this3._snapshotRevision;\n        var backup = subscription.backup;\n        subscription.backup = null;\n\n        if (backup) {\n          if (backup.data !== subscription.snapshot.data) {\n            _this3._staleSubscriptions.add(subscription);\n          }\n\n          var prevSeenRecords = subscription.snapshot.seenRecords;\n          subscription.snapshot = {\n            data: subscription.snapshot.data,\n            isMissingData: backup.isMissingData,\n            seenRecords: backup.seenRecords,\n            selector: backup.selector,\n            missingRequiredFields: backup.missingRequiredFields\n          };\n\n          _this3._updateSubscriptionsMap(subscription, prevSeenRecords);\n        } else {\n          _this3._staleSubscriptions.add(subscription);\n        }\n      });\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this4 = this;\n\n    this._notifiedRevision++;\n    updatedRecordIDs.forEach(function (updatedRecordId) {\n      var subcriptionsForDataId = _this4._subscriptionsByDataId.get(updatedRecordId);\n\n      if (subcriptionsForDataId == null) {\n        return;\n      }\n\n      subcriptionsForDataId.forEach(function (subscription) {\n        if (subscription.notifiedRevision === _this4._notifiedRevision) {\n          return;\n        }\n\n        var owner = _this4._updateSubscription(source, subscription, false, sourceOperation);\n\n        if (owner != null) {\n          updatedOwners.push(owner);\n        }\n      });\n    });\n\n    this._staleSubscriptions.forEach(function (subscription) {\n      if (subscription.notifiedRevision === _this4._notifiedRevision) {\n        return;\n      }\n\n      var owner = _this4._updateSubscription(source, subscription, true, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._staleSubscriptions.clear();\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * amarks it as not stale, and updates the subscription tracking for any\n   * any new ids observed in the latest data snapshot.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, stale, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot;\n    var nextSnapshot = stale && backup != null ? backup : RelayReader.read(source, snapshot.selector);\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    var prevSeenRecords = subscription.snapshot.seenRecords;\n    subscription.snapshot = nextSnapshot;\n    subscription.notifiedRevision = this._notifiedRevision;\n\n    this._updateSubscriptionsMap(subscription, prevSeenRecords);\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  }\n  /**\n   * Updates the Map that tracks subscriptions by id.\n   * Given an updated subscription and the records that where seen\n   * on the previous subscription snapshot, updates our tracking\n   * to track the subscription for the newly and no longer seen ids.\n   */\n  ;\n\n  _proto._updateSubscriptionsMap = function _updateSubscriptionsMap(subscription, prevSeenRecords) {\n    var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])(prevSeenRecords),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var dataId = _step3.value;\n\n        var subscriptionsForDataId = this._subscriptionsByDataId.get(dataId);\n\n        if (subscriptionsForDataId != null) {\n          subscriptionsForDataId[\"delete\"](subscription);\n\n          if (subscriptionsForDataId.size === 0) {\n            this._subscriptionsByDataId[\"delete\"](dataId);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = (0, _createForOfIteratorHelper2[\"default\"])(subscription.snapshot.seenRecords),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _dataId = _step4.value;\n\n        var _subscriptionsForDataId = this._subscriptionsByDataId.get(_dataId);\n\n        if (_subscriptionsForDataId != null) {\n          _subscriptionsForDataId.add(subscription);\n        } else {\n          this._subscriptionsByDataId.set(_dataId, new Set([subscription]));\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  return RelayStoreSubscriptionsUsingMapByID;\n}();\n\nmodule.exports = RelayStoreSubscriptionsUsingMapByID;"]},"metadata":{},"sourceType":"script"}