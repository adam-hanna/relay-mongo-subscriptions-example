{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReader = require('./RelayReader');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log) {\n    this._subscriptions = new Set();\n    this.__log = log;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this2 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this2._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js"],"names":["RelayFeatureFlags","require","RelayReader","deepFreeze","hasOverlappingIDs","recycleNodesInto","RelayStoreSubscriptions","log","_subscriptions","Set","__log","_proto","prototype","subscribe","snapshot","callback","_this","subscription","backup","stale","dispose","add","snapshotSubscriptions","source","forEach","read","selector","nextData","data","restoreSubscriptions","isMissingData","seenRecords","missingRequiredFields","updateSubscriptions","updatedRecordIDs","updatedOwners","sourceOperation","_this2","hasUpdatedRecords","size","owner","_updateSubscription","push","hasOverlappingUpdates","nextSnapshot","process","env","NODE_ENV","ENABLE_NOTIFY_SUBSCRIPTION","name","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReader = require('./RelayReader');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log) {\n    this._subscriptions = new Set();\n    this.__log = log;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this2 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this2._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;"]},"metadata":{},"sourceType":"script"}