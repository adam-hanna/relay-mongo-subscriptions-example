{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest;\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\n\n\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\n\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      var query = nextProps.query;\n      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n      prevState.queryFetcher.disposeRequest();\n      var queryFetcher;\n\n      if (query) {\n        var request = getRequest(query);\n        var requestCacheKey = getRequestCacheKey(request.params, nextProps.variables);\n        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n      } else {\n        queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n      }\n\n      return (0, _objectSpread2[\"default\"])({\n        prevQuery: nextProps.query,\n        prevPropsEnvironment: nextProps.environment,\n        prevPropsVariables: nextProps.variables,\n        queryFetcher: queryFetcher\n      }, fetchQueryAndComputeStateFromProps(nextProps, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n      // and we want the updated requestCacheKey, since variables may have changed\n      ));\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    };\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // We don't need to cache the request after the component commits\n    var requestCacheKey = this.state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state2 = this.state,\n        renderProps = _this$state2.renderProps,\n        relayContext = _this$state2.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables,\n      cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: retryCallbacks.handleDataChange,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/react-relay/lib/ReactRelayQueryRenderer.js"],"names":["_interopRequireDefault","require","_objectSpread2","_inheritsLoose2","React","ReactRelayContext","ReactRelayQueryFetcher","ReactRelayQueryRendererContext","areEqual","_require","createOperationDescriptor","deepFreeze","getRequest","requestCache","queryRendererContext","rootIsQueryRenderer","ReactRelayQueryRenderer","_React$Component","props","_this","call","retryCallbacks","handleDataChange","handleRetryAfterError","queryFetcher","requestCacheKey","query","request","getRequestCacheKey","params","variables","state","prevPropsEnvironment","environment","prevPropsVariables","prevQuery","fetchQueryAndComputeStateFromProps","getDerivedStateFromProps","nextProps","prevState","prevSelectionReferences","getSelectionReferences","disposeRequest","_proto","prototype","componentDidMount","_this2","_this$state","error","snapshot","setState","prevRequestCacheKey","renderProps","getRenderProps","getLoadingRenderProps","setOnDataChange","componentDidUpdate","componentWillUnmount","dispose","shouldComponentUpdate","nextState","render","_this$state2","relayContext","process","env","NODE_ENV","createElement","Provider","value","Component","retry","getEmptyRenderProps","data","cacheConfigOverride","syncSnapshot","JSON","stringify","id","cacheID","cacheConfig","genericEnvironment","operation","storeSnapshot","lookupInStore","fetchPolicy","querySnapshot","fetch","onDataChange","_snapshot","_relayContext","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest;\n\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      var query = nextProps.query;\n      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n      prevState.queryFetcher.disposeRequest();\n      var queryFetcher;\n\n      if (query) {\n        var request = getRequest(query);\n        var requestCacheKey = getRequestCacheKey(request.params, nextProps.variables);\n        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n      } else {\n        queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n      }\n\n      return (0, _objectSpread2[\"default\"])({\n        prevQuery: nextProps.query,\n        prevPropsEnvironment: nextProps.environment,\n        prevPropsVariables: nextProps.variables,\n        queryFetcher: queryFetcher\n      }, fetchQueryAndComputeStateFromProps(nextProps, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n      // and we want the updated requestCacheKey, since variables may have changed\n      ));\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    };\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // We don't need to cache the request after the component commits\n    var requestCacheKey = this.state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state2 = this.state,\n        renderProps = _this$state2.renderProps,\n        relayContext = _this$state2.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables,\n      cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: retryCallbacks.handleDataChange,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;"]},"metadata":{},"sourceType":"script"}