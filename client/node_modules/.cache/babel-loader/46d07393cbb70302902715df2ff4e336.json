{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    getPromiseForActiveRequest = _require.__internal.getPromiseForActiveRequest,\n    getFragmentIdentifier = _require.getFragmentIdentifier,\n    getSelector = _require.getSelector,\n    isPromise = _require.isPromise,\n    recycleNodesInto = _require.recycleNodesInto,\n    reportMissingRequiredFields = _require.reportMissingRequiredFields;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function'; // TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\n\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction getFragmentResult(cacheKey, snapshot) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      })\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data\n  };\n}\n\nfunction getPromiseForPendingOperationAffectingOwner(environment, request) {\n  return environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(request);\n}\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto = FragmentResourceImpl.prototype;\n\n  _proto.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _fragmentNode$metadat;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        snapshot: null\n      };\n    } // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      if (isPromise(cachedValue)) {\n        throw cachedValue;\n      }\n\n      if (cachedValue.snapshot) {\n        this._reportMissingRequiredFieldsInSnapshot(cachedValue.snapshot);\n\n        return cachedValue;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    if (!isMissingData(snapshot)) {\n      this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n      var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot);\n\n      this._cache.set(fragmentIdentifier, fragmentResult);\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, check if a request is in\n    // flight for the fragment's parent query, or for another operation\n    // that may affect the parent's query data, such as a mutation\n    // or subscription. If a promise exists, cache the promise and use it\n    // to suspend.\n\n\n    var networkPromise = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner);\n\n    if (networkPromise != null) {\n      throw networkPromise;\n    }\n\n    this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot);\n  };\n\n  _proto._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {\n    var _this = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        if (s.missingRequiredFields != null) {\n          reportMissingRequiredFields(_this._environment, s.missingRequiredFields);\n        }\n      });\n    } else {\n      if (snapshot.missingRequiredFields != null) {\n        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);\n      }\n    }\n  };\n\n  _proto.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto.subscribe = function subscribe(fragmentResult, callback) {\n    var _this2 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var dataSubscriptions = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        dataSubscriptions.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          _this2._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      dataSubscriptions.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        _this2._cache.set(cacheKey, getFragmentResult(cacheKey, latestSnapshot));\n\n        callback();\n      }));\n    }\n\n    return {\n      dispose: function dispose() {\n        dataSubscriptions.map(function (s) {\n          return s.dispose();\n        });\n\n        _this2._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this3 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this3.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var didMissUpdates = false;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      });\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, getFragmentResult(cacheKey, currentSnapshots));\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    currentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, getFragmentResult(cacheKey, currentSnapshot));\n\n      didMissUpdates = true;\n    }\n\n    return [didMissUpdates, currentSnapshot];\n  };\n\n  _proto.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this4 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this4.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner) {\n    var _this5 = this;\n\n    var _getPromiseForActiveR;\n\n    var environment = this._environment;\n    var networkPromise = (_getPromiseForActiveR = getPromiseForActiveRequest(environment, fragmentOwner)) !== null && _getPromiseForActiveR !== void 0 ? _getPromiseForActiveR : getPromiseForPendingOperationAffectingOwner(environment, fragmentOwner);\n\n    if (!networkPromise) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var promise = networkPromise.then(function () {\n      _this5._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this5._cache[\"delete\"](cacheKey);\n    });\n\n    this._cache.set(cacheKey, promise);\n\n    var queryName = fragmentOwner.node.params.name;\n    var fragmentName = fragmentNode.name;\n    var promiseDisplayName = queryName === fragmentName ? \"Relay(\".concat(queryName, \")\") : \"Relay(\".concat(queryName, \":\").concat(fragmentName, \")\"); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = promiseDisplayName;\n    return promise;\n  };\n\n  _proto._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx) {\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : currentFragmentResult.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, getFragmentResult(cacheKey, nextSnapshots));\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/react-relay/lib/relay-hooks/FragmentResource.js"],"names":["_interopRequireDefault","require","_objectSpread2","_toConsumableArray2","LRUCache","invariant","_require","getPromiseForActiveRequest","__internal","getFragmentIdentifier","getSelector","isPromise","recycleNodesInto","reportMissingRequiredFields","WEAKMAP_SUPPORTED","WeakMap","CACHE_CAPACITY","CONSTANT_READONLY_EMPTY_ARRAY","Object","freeze","isMissingData","snapshot","Array","isArray","some","s","getFragmentResult","cacheKey","data","map","getPromiseForPendingOperationAffectingOwner","environment","request","getOperationTracker","getPromiseForPendingOperationsAffectingOwner","FragmentResourceImpl","_environment","_cache","create","_proto","prototype","read","fragmentNode","fragmentRef","componentDisplayName","fragmentKey","readWithIdentifier","fragmentIdentifier","_fragmentNode$metadat","metadata","plural","process","env","NODE_ENV","concat","name","length","cachedValue","get","_reportMissingRequiredFieldsInSnapshot","fragmentSelector","kind","selectors","lookup","fragmentOwner","owner","fragmentResult","set","networkPromise","_getAndSavePromiseForFragmentRequestInFlight","_this","forEach","missingRequiredFields","readSpec","fragmentNodes","fragmentRefs","result","_key","subscribe","callback","_this2","renderedSnapshot","dispose","_this$checkMissedUpda","checkMissedUpdates","didMissUpdates","currentSnapshot","dataSubscriptions","idx","push","latestSnapshot","_updatePluralSnapshot","subscribeSpec","fragmentResults","_this3","disposables","keys","key","disposable","currentSnapshots","selector","renderData","currentData","updatedData","seenRecords","checkMissedUpdatesSpec","_this4","_this5","_getPromiseForActiveR","promise","then","error","queryName","node","params","fragmentName","promiseDisplayName","displayName","baseSnapshots","currentFragmentResult","reportInvalidCachedData","nextSnapshots","nodeName","createFragmentResource","dataResources","Map","getFragmentResourceForEnvironment","cached","newDataResource","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    getPromiseForActiveRequest = _require.__internal.getPromiseForActiveRequest,\n    getFragmentIdentifier = _require.getFragmentIdentifier,\n    getSelector = _require.getSelector,\n    isPromise = _require.isPromise,\n    recycleNodesInto = _require.recycleNodesInto,\n    reportMissingRequiredFields = _require.reportMissingRequiredFields;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction getFragmentResult(cacheKey, snapshot) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      })\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data\n  };\n}\n\nfunction getPromiseForPendingOperationAffectingOwner(environment, request) {\n  return environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(request);\n}\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto = FragmentResourceImpl.prototype;\n\n  _proto.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _fragmentNode$metadat;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        snapshot: null\n      };\n    } // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      if (isPromise(cachedValue)) {\n        throw cachedValue;\n      }\n\n      if (cachedValue.snapshot) {\n        this._reportMissingRequiredFieldsInSnapshot(cachedValue.snapshot);\n\n        return cachedValue;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    if (!isMissingData(snapshot)) {\n      this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n      var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot);\n\n      this._cache.set(fragmentIdentifier, fragmentResult);\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, check if a request is in\n    // flight for the fragment's parent query, or for another operation\n    // that may affect the parent's query data, such as a mutation\n    // or subscription. If a promise exists, cache the promise and use it\n    // to suspend.\n\n\n    var networkPromise = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner);\n\n    if (networkPromise != null) {\n      throw networkPromise;\n    }\n\n    this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot);\n  };\n\n  _proto._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {\n    var _this = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        if (s.missingRequiredFields != null) {\n          reportMissingRequiredFields(_this._environment, s.missingRequiredFields);\n        }\n      });\n    } else {\n      if (snapshot.missingRequiredFields != null) {\n        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);\n      }\n    }\n  };\n\n  _proto.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto.subscribe = function subscribe(fragmentResult, callback) {\n    var _this2 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var dataSubscriptions = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        dataSubscriptions.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          _this2._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      dataSubscriptions.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        _this2._cache.set(cacheKey, getFragmentResult(cacheKey, latestSnapshot));\n\n        callback();\n      }));\n    }\n\n    return {\n      dispose: function dispose() {\n        dataSubscriptions.map(function (s) {\n          return s.dispose();\n        });\n\n        _this2._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this3 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this3.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var didMissUpdates = false;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      });\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, getFragmentResult(cacheKey, currentSnapshots));\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    currentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, getFragmentResult(cacheKey, currentSnapshot));\n\n      didMissUpdates = true;\n    }\n\n    return [didMissUpdates, currentSnapshot];\n  };\n\n  _proto.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this4 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this4.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner) {\n    var _this5 = this;\n\n    var _getPromiseForActiveR;\n\n    var environment = this._environment;\n    var networkPromise = (_getPromiseForActiveR = getPromiseForActiveRequest(environment, fragmentOwner)) !== null && _getPromiseForActiveR !== void 0 ? _getPromiseForActiveR : getPromiseForPendingOperationAffectingOwner(environment, fragmentOwner);\n\n    if (!networkPromise) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var promise = networkPromise.then(function () {\n      _this5._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this5._cache[\"delete\"](cacheKey);\n    });\n\n    this._cache.set(cacheKey, promise);\n\n    var queryName = fragmentOwner.node.params.name;\n    var fragmentName = fragmentNode.name;\n    var promiseDisplayName = queryName === fragmentName ? \"Relay(\".concat(queryName, \")\") : \"Relay(\".concat(queryName, \":\").concat(fragmentName, \")\"); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = promiseDisplayName;\n    return promise;\n  };\n\n  _proto._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx) {\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : currentFragmentResult.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, getFragmentResult(cacheKey, nextSnapshots));\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};"]},"metadata":{},"sourceType":"script"}