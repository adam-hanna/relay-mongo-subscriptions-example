{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n/**\n * Determines the variables that are in scope for a fragment given the variables\n * in scope at the root query as well as any arguments applied at the fragment\n * spread via `@arguments`.\n *\n * Note that this is analagous to determining function arguments given a function call.\n */\n\n\nfunction getFragmentVariables(fragment, rootVariables, argumentVariables) {\n  var variables;\n  fragment.argumentDefinitions.forEach(function (definition) {\n    if (argumentVariables.hasOwnProperty(definition.name)) {\n      return;\n    } // $FlowFixMe[cannot-spread-interface]\n\n\n    variables = variables || (0, _objectSpread2[\"default\"])({}, argumentVariables);\n\n    switch (definition.kind) {\n      case 'LocalArgument':\n        variables[definition.name] = definition.defaultValue;\n        break;\n\n      case 'RootArgument':\n        if (!rootVariables.hasOwnProperty(definition.name)) {\n          /*\n           * Global variables passed as values of @arguments are not required to\n           * be declared unless they are used by the callee fragment or a\n           * descendant. In this case, the root variable may not be defined when\n           * resolving the callee's variables. The value is explicitly set to\n           * undefined to conform to the check in\n           * RelayStoreUtils.getStableVariableValue() that variable keys are all\n           * present.\n           */\n          // $FlowFixMe[incompatible-use]\n          variables[definition.name] = undefined;\n          break;\n        } // $FlowFixMe[incompatible-use]\n        // $FlowFixMe[cannot-write]\n\n\n        variables[definition.name] = rootVariables[definition.name];\n        break;\n\n      default:\n        definition;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : invariant(false) : void 0;\n    }\n  });\n  return variables || argumentVariables;\n}\n/**\n * Determines the variables that are in scope for a given operation given values\n * for some/all of its arguments. Extraneous input variables are filtered from\n * the output, and missing variables are set to default values (if given in the\n * operation's definition).\n */\n\n\nfunction getOperationVariables(operation, variables) {\n  var operationVariables = {};\n  operation.argumentDefinitions.forEach(function (def) {\n    var value = def.defaultValue; // $FlowFixMe[cannot-write]\n\n    if (variables[def.name] != null) {\n      value = variables[def.name];\n    }\n\n    operationVariables[def.name] = value;\n  });\n  return operationVariables;\n}\n\nmodule.exports = {\n  getFragmentVariables: getFragmentVariables,\n  getOperationVariables: getOperationVariables\n};","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js"],"names":["_interopRequireDefault","require","_objectSpread2","invariant","getFragmentVariables","fragment","rootVariables","argumentVariables","variables","argumentDefinitions","forEach","definition","hasOwnProperty","name","kind","defaultValue","undefined","process","env","NODE_ENV","getOperationVariables","operation","operationVariables","def","value","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,cAAc,GAAGF,sBAAsB,CAACC,OAAO,CAAC,sCAAD,CAAR,CAA3C;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,oBAAT,CAA8BC,QAA9B,EAAwCC,aAAxC,EAAuDC,iBAAvD,EAA0E;AACxE,MAAIC,SAAJ;AACAH,EAAAA,QAAQ,CAACI,mBAAT,CAA6BC,OAA7B,CAAqC,UAAUC,UAAV,EAAsB;AACzD,QAAIJ,iBAAiB,CAACK,cAAlB,CAAiCD,UAAU,CAACE,IAA5C,CAAJ,EAAuD;AACrD;AACD,KAHwD,CAGvD;;;AAGFL,IAAAA,SAAS,GAAGA,SAAS,IAAI,CAAC,GAAGN,cAAc,CAAC,SAAD,CAAlB,EAA+B,EAA/B,EAAmCK,iBAAnC,CAAzB;;AAEA,YAAQI,UAAU,CAACG,IAAnB;AACE,WAAK,eAAL;AACEN,QAAAA,SAAS,CAACG,UAAU,CAACE,IAAZ,CAAT,GAA6BF,UAAU,CAACI,YAAxC;AACA;;AAEF,WAAK,cAAL;AACE,YAAI,CAACT,aAAa,CAACM,cAAd,CAA6BD,UAAU,CAACE,IAAxC,CAAL,EAAoD;AAClD;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACU;AACAL,UAAAA,SAAS,CAACG,UAAU,CAACE,IAAZ,CAAT,GAA6BG,SAA7B;AACA;AACD,SAdH,CAcI;AACF;;;AAGAR,QAAAA,SAAS,CAACG,UAAU,CAACE,IAAZ,CAAT,GAA6BP,aAAa,CAACK,UAAU,CAACE,IAAZ,CAA1C;AACA;;AAEF;AACEF,QAAAA,UAAU;AACV,SAAC,KAAD,GAASM,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwChB,SAAS,CAAC,KAAD,EAAQ,qEAAR,EAA+EQ,UAAU,CAACG,IAA1F,EAAgGT,QAAQ,CAACQ,IAAzG,CAAjD,GAAkKV,SAAS,CAAC,KAAD,CAApL,GAA8L,KAAK,CAAnM;AA5BJ;AA8BD,GAtCD;AAuCA,SAAOK,SAAS,IAAID,iBAApB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASa,qBAAT,CAA+BC,SAA/B,EAA0Cb,SAA1C,EAAqD;AACnD,MAAIc,kBAAkB,GAAG,EAAzB;AACAD,EAAAA,SAAS,CAACZ,mBAAV,CAA8BC,OAA9B,CAAsC,UAAUa,GAAV,EAAe;AACnD,QAAIC,KAAK,GAAGD,GAAG,CAACR,YAAhB,CADmD,CACrB;;AAE9B,QAAIP,SAAS,CAACe,GAAG,CAACV,IAAL,CAAT,IAAuB,IAA3B,EAAiC;AAC/BW,MAAAA,KAAK,GAAGhB,SAAS,CAACe,GAAG,CAACV,IAAL,CAAjB;AACD;;AAEDS,IAAAA,kBAAkB,CAACC,GAAG,CAACV,IAAL,CAAlB,GAA+BW,KAA/B;AACD,GARD;AASA,SAAOF,kBAAP;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiB;AACftB,EAAAA,oBAAoB,EAAEA,oBADP;AAEfgB,EAAAA,qBAAqB,EAAEA;AAFR,CAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\n/**\n * Determines the variables that are in scope for a fragment given the variables\n * in scope at the root query as well as any arguments applied at the fragment\n * spread via `@arguments`.\n *\n * Note that this is analagous to determining function arguments given a function call.\n */\nfunction getFragmentVariables(fragment, rootVariables, argumentVariables) {\n  var variables;\n  fragment.argumentDefinitions.forEach(function (definition) {\n    if (argumentVariables.hasOwnProperty(definition.name)) {\n      return;\n    } // $FlowFixMe[cannot-spread-interface]\n\n\n    variables = variables || (0, _objectSpread2[\"default\"])({}, argumentVariables);\n\n    switch (definition.kind) {\n      case 'LocalArgument':\n        variables[definition.name] = definition.defaultValue;\n        break;\n\n      case 'RootArgument':\n        if (!rootVariables.hasOwnProperty(definition.name)) {\n          /*\n           * Global variables passed as values of @arguments are not required to\n           * be declared unless they are used by the callee fragment or a\n           * descendant. In this case, the root variable may not be defined when\n           * resolving the callee's variables. The value is explicitly set to\n           * undefined to conform to the check in\n           * RelayStoreUtils.getStableVariableValue() that variable keys are all\n           * present.\n           */\n          // $FlowFixMe[incompatible-use]\n          variables[definition.name] = undefined;\n          break;\n        } // $FlowFixMe[incompatible-use]\n        // $FlowFixMe[cannot-write]\n\n\n        variables[definition.name] = rootVariables[definition.name];\n        break;\n\n      default:\n        definition;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : invariant(false) : void 0;\n    }\n  });\n  return variables || argumentVariables;\n}\n/**\n * Determines the variables that are in scope for a given operation given values\n * for some/all of its arguments. Extraneous input variables are filtered from\n * the output, and missing variables are set to default values (if given in the\n * operation's definition).\n */\n\n\nfunction getOperationVariables(operation, variables) {\n  var operationVariables = {};\n  operation.argumentDefinitions.forEach(function (def) {\n    var value = def.defaultValue; // $FlowFixMe[cannot-write]\n\n    if (variables[def.name] != null) {\n      value = variables[def.name];\n    }\n\n    operationVariables[def.name] = value;\n  });\n  return operationVariables;\n}\n\nmodule.exports = {\n  getFragmentVariables: getFragmentVariables,\n  getOperationVariables: getOperationVariables\n};"]},"metadata":{},"sourceType":"script"}