{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar getOperation = require('../util/getOperation');\n\nvar invariant = require('invariant');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID,\n    generateUniqueClientID = _require.generateUniqueClientID;\n\nvar _require2 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require2.createNormalizationSelector,\n    createReaderSelector = _require2.createReaderSelector;\n\nvar _require3 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require3.ROOT_TYPE,\n    TYPENAME_KEY = _require3.TYPENAME_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        optimisticConfig = _ref.optimisticConfig,\n        publishQueue = _ref.publishQueue,\n        scheduler = _ref.scheduler,\n        sink = _ref.sink,\n        source = _ref.source,\n        store = _ref.store,\n        updater = _ref.updater,\n        operationTracker = _ref.operationTracker,\n        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,\n        getDataID = _ref.getDataID,\n        isClientPayload = _ref.isClientPayload,\n        reactFlightPayloadDeserializer = _ref.reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler = _ref.reactFlightServerErrorHandler,\n        shouldProcessClientComponents = _ref.shouldProcessClientComponents;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._publishQueue = publishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._store = store;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    this._reactFlightPayloadDeserializer = reactFlightPayloadDeserializer;\n    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;\n    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        return _this._start(id, subscription);\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._publishQueue.revertUpdate(update);\n      }); // OK: run revert on cancel\n\n      this._publishQueue.run();\n    }\n\n    this._incrementalResults.clear();\n\n    this._completeOperationTracker();\n\n    if (this._retainDisposable) {\n      this._retainDisposable.dispose();\n\n      this._retainDisposable = null;\n    }\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      _this4._handleNext(response);\n\n      _this4._maybeCompleteSubscriptionOperationTracking();\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1];\n\n    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at most one non-incremental payload\n    //  * followed by zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // with the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n    if (hasNonIncrementalResponses) {\n      var payloadFollowups = this._processResponses(nonIncrementalResponses);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        var updatedOwners = this._publishQueue.run(this._operation);\n\n        this._updateOperationTracker(updatedOwners);\n      }\n\n      this._processPayloadFollowups(payloadFollowups);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        if (this._incrementalPayloadsPending && !this._retainDisposable) {\n          this._retainDisposable = this._store.retain(this._operation);\n        }\n      }\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        // For the incremental case, we're only handling follow-up responses\n        // for already initiated operation (and we're not passing it to\n        // the run(...) call)\n        var _updatedOwners = this._publishQueue.run();\n\n        this._updateOperationTracker(_updatedOwners);\n      }\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    if (this._isSubscriptionOperation && RelayFeatureFlags.ENABLE_UNIQUE_SUBSCRIPTION_ROOT) {\n      // We attach the id to allow the `requestSubscription` to read from the store using\n      // the current id in its `onNext` callback\n      if (responsesWithData[0].extensions == null) {\n        // $FlowFixMe[cannot-write]\n        responsesWithData[0].extensions = {\n          __relay_subscription_root_id: this._operation.fragment.dataID\n        };\n      } else {\n        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;\n      }\n    }\n\n    if (RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n      // OK: run once after each new payload\n      // If we have non-incremental responses, we passing `this._operation` to\n      // the publish queue here, which will later be passed to the store (via\n      // notify) to indicate that this operation caused the store to update\n      var _updatedOwners2 = this._publishQueue.run(hasNonIncrementalResponses ? this._operation : undefined);\n\n      if (hasNonIncrementalResponses) {\n        if (this._incrementalPayloadsPending && !this._retainDisposable) {\n          this._retainDisposable = this._store.retain(this._operation);\n        }\n      }\n\n      this._updateOperationTracker(_updatedOwners2);\n    }\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        getDataID: this._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n        shouldProcessClientComponents: this._shouldProcessClientComponents,\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          moduleImportPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._publishQueue.applyUpdate(update);\n    }); // OK: only called on construction and when receiving an optimistic payload from network,\n    // which doesn't fall-through to the regular next() handling\n\n    this._publishQueue.run();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {\n      var moduleImportPayloads = payload.moduleImportPayloads;\n      var operationLoader = this._operationLoader;\n      !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(moduleImportPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var moduleImportPayload = _step.value;\n          var operation = operationLoader.get(moduleImportPayload.operationReference);\n\n          if (operation == null) {\n            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);\n          } else {\n            var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);\n\n            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {\n    var selector = createNormalizationSelector(operation, moduleImportPayload.dataID, moduleImportPayload.variables);\n    return normalizeResponse({\n      data: moduleImportPayload.data\n    }, selector, moduleImportPayload.typeName, {\n      getDataID: this._getDataID,\n      path: moduleImportPayload.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {\n    var operation = getOperation(normalizationRootNode);\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {\n    var _this7 = this;\n\n    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisticUpdates.forEach(function (update) {\n        return _this7._publishQueue.applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async\n\n\n        _this7._publishQueue.run();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        return _this8._publishQueue.revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        getDataID: _this8._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        shouldProcessClientComponents: _this8._shouldProcessClientComponents\n      });\n\n      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          moduleImportPayloads = payload.moduleImportPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {\n        var operationLoader = _this9._operationLoader;\n        !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n        moduleImportPayloads.forEach(function (moduleImportPayload) {\n          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n              var updatedOwners = _this9._publishQueue.run();\n\n              _this9._updateOperationTracker(updatedOwners);\n            }\n\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    if (!this._isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n\n    if (RelayFeatureFlags.ENABLE_UNIQUE_SUBSCRIPTION_ROOT) {\n      var nextID = generateUniqueClientID();\n      this._operation = {\n        request: this._operation.request,\n        fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),\n        root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)\n      };\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {\n    var _this10 = this;\n\n    var node = operationLoader.get(moduleImportPayload.operationReference);\n\n    if (node != null) {\n      var operation = getOperation(node); // If the operation module is available synchronously, normalize the\n      // data synchronously.\n\n      this._handleModuleImportPayload(moduleImportPayload, operation);\n\n      this._maybeCompleteSubscriptionOperationTracking();\n    } else {\n      // Otherwise load the operation module and schedule a task to normalize\n      // the data when the module is available.\n      var _id3 = this._nextSubscriptionId++;\n\n      this._pendingModulePayloadsCount++;\n\n      var decrementPendingCount = function decrementPendingCount() {\n        _this10._pendingModulePayloadsCount--;\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n      // errors thrown by the load function, which is user-defined. Guard\n      // against that with Observable.from(new Promise(<work>)).\n\n\n      RelayObservable.from(new Promise(function (resolve, reject) {\n        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);\n      })).map(function (operation) {\n        if (operation != null) {\n          _this10._schedule(function () {\n            _this10._handleModuleImportPayload(moduleImportPayload, getOperation(operation)); // OK: always have to run after an async module import resolves\n\n\n            var updatedOwners = _this10._publishQueue.run();\n\n            _this10._updateOperationTracker(updatedOwners);\n          });\n        }\n      }).subscribe({\n        complete: function complete() {\n          _this10._complete(_id3);\n\n          decrementPendingCount();\n        },\n        error: function error(_error4) {\n          _this10._error(_error4);\n\n          decrementPendingCount();\n        },\n        start: function start(subscription) {\n          return _this10._start(_id3, subscription);\n        }\n      });\n    }\n  };\n\n  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {\n    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    this._publishQueue.commitPayload(this._operation, relayPayload);\n\n    if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n      var updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(updatedOwners);\n    }\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa; // Update the label => path => placeholder map\n\n\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        var updatedOwners = this._publishQueue.run();\n\n        this._updateOperationTracker(updatedOwners);\n      }\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var parentID = placeholder.selector.dataID;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n\n    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    this._operationTracker.complete(this._operation.request);\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, relayPayload), {}, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/OperationExecutor.js"],"names":["_interopRequireDefault","require","_objectSpread2","_createForOfIteratorHelper2","_toConsumableArray2","RelayError","RelayFeatureFlags","RelayModernRecord","RelayObservable","RelayRecordSource","RelayResponseNormalizer","getOperation","invariant","stableCopy","warning","_require","generateClientID","generateUniqueClientID","_require2","createNormalizationSelector","createReaderSelector","_require3","ROOT_TYPE","TYPENAME_KEY","getStorageKey","execute","config","Executor","_ref","_this","operation","operationExecutions","operationLoader","optimisticConfig","publishQueue","scheduler","sink","source","store","updater","operationTracker","treatMissingFieldsAsNull","getDataID","isClientPayload","reactFlightPayloadDeserializer","reactFlightServerErrorHandler","shouldProcessClientComponents","_getDataID","_treatMissingFieldsAsNull","_incrementalPayloadsPending","_incrementalResults","Map","_nextSubscriptionId","_operation","_operationExecutions","_operationLoader","_operationTracker","_operationUpdateEpochs","_optimisticUpdates","_pendingModulePayloadsCount","_publishQueue","_scheduler","_sink","_source","_state","_store","_subscriptions","_updater","_isClientPayload","_reactFlightPayloadDeserializer","_reactFlightServerErrorHandler","_isSubscriptionOperation","request","node","params","operationKind","_shouldProcessClientComponents","id","subscribe","complete","_complete","error","_error2","_error","next","response","_next","start","subscription","_start","_processOptimisticResponse","data","_proto","prototype","cancel","_this2","identifier","size","forEach","sub","unsubscribe","clear","optimisticUpdates","update","revertUpdate","run","_completeOperationTracker","_retainDisposable","dispose","_updateActiveState","activeState","process","env","NODE_ENV","set","_schedule","task","_this3","_id2","create","cancellationToken","schedule","_error3","_id","_this4","_handleNext","_maybeCompleteSubscriptionOperationTracking","_handleErrorResponse","responses","_this5","results","extensions","hasOwnProperty","errors","messages","map","_ref2","message","join","name","variables","stack","responseWithData","push","_handleOptimisticResponses","_response$extensions","length","some","responsePart","_responsePart$extensi","isOptimistic","Array","isArray","responsesWithData","isFinal","x","_x$extensions","is_final","_partitionGraphQLResp","partitionGraphQLResponses","nonIncrementalResponses","incrementalResponses","hasNonIncrementalResponses","payloadFollowups","_processResponses","ENABLE_BATCHED_STORE_UPDATES","updatedOwners","_updateOperationTracker","_processPayloadFollowups","retain","_payloadFollowups","_processIncrementalResponses","_updatedOwners","ENABLE_UNIQUE_SUBSCRIPTION_ROOT","__relay_subscription_root_id","fragment","dataID","_updatedOwners2","undefined","_this6","payload","normalizeResponse","root","path","validateOptimisticResponsePayload","_processOptimisticFollowups","fieldPayloads","incrementalPlaceholders","moduleImportPayloads","applyUpdate","_iterator","_step","s","n","done","moduleImportPayload","value","get","operationReference","_processAsyncOptimisticModuleImport","moduleImportOptimisticUpdates","_processOptimisticModuleImport","apply","err","e","f","_normalizeModuleImport","selector","typeName","normalizationRootNode","modulePayload","_this7","load","then","_this$_optimisticUpda","_this8","payloadPart","relayPayload","commitPayload","payloads","_this9","_processModuleImportPayload","incrementalPlaceholder","_processIncrementalPlaceholder","relayPayloads","placeholder","kind","_processDeferResponse","label","nextID","owner","_this10","_handleModuleImportPayload","_id3","decrementPendingCount","from","Promise","resolve","reject","_error4","_relayPayload$fieldPa","pathKey","String","resultForLabel","resultForPath","pendingResponses","parentID","parentRecord","parentPayloads","filter","fieldPayload","fieldID","fieldKey","nextParentRecord","nextParentPayloads","previousParentEntry","record","handlePayloads","dedupePayload","key","stableStringify","values","_this11","incrementalResponse","indexOf","_pathKey","slice","_resultForPath","_placeholder","_processStreamResponse","parentEntry","_response$extensions2","handleFieldsRelayPayload","field","selections","plural","_this$_normalizeStrea","_normalizeStreamItem","itemID","itemIndex","prevIDs","storageKey","currentParentRecord","currentItems","getLinkedRecords","currentItem","index","nextItems","setLinkedRecords","normalizationPath","_field$alias","_field$concreteType","_this$_getDataID","responseKey","alias","getLinkedRecordIDs","finalPathEntry","parseInt","concreteType","clone","nextIDs","setLinkedRecordIDs","concat","Set","options","_response$extensions3","normalize","_JSON$stringify","JSON","stringify","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar getOperation = require('../util/getOperation');\n\nvar invariant = require('invariant');\n\nvar stableCopy = require('../util/stableCopy');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID,\n    generateUniqueClientID = _require.generateUniqueClientID;\n\nvar _require2 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require2.createNormalizationSelector,\n    createReaderSelector = _require2.createReaderSelector;\n\nvar _require3 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require3.ROOT_TYPE,\n    TYPENAME_KEY = _require3.TYPENAME_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        optimisticConfig = _ref.optimisticConfig,\n        publishQueue = _ref.publishQueue,\n        scheduler = _ref.scheduler,\n        sink = _ref.sink,\n        source = _ref.source,\n        store = _ref.store,\n        updater = _ref.updater,\n        operationTracker = _ref.operationTracker,\n        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,\n        getDataID = _ref.getDataID,\n        isClientPayload = _ref.isClientPayload,\n        reactFlightPayloadDeserializer = _ref.reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler = _ref.reactFlightServerErrorHandler,\n        shouldProcessClientComponents = _ref.shouldProcessClientComponents;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._publishQueue = publishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._store = store;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    this._reactFlightPayloadDeserializer = reactFlightPayloadDeserializer;\n    this._reactFlightServerErrorHandler = reactFlightServerErrorHandler;\n    this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n    this._shouldProcessClientComponents = shouldProcessClientComponents;\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        return _this._start(id, subscription);\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._publishQueue.revertUpdate(update);\n      }); // OK: run revert on cancel\n\n      this._publishQueue.run();\n    }\n\n    this._incrementalResults.clear();\n\n    this._completeOperationTracker();\n\n    if (this._retainDisposable) {\n      this._retainDisposable.dispose();\n\n      this._retainDisposable = null;\n    }\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      _this4._handleNext(response);\n\n      _this4._maybeCompleteSubscriptionOperationTracking();\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1];\n\n    var hasNonIncrementalResponses = nonIncrementalResponses.length > 0; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at most one non-incremental payload\n    //  * followed by zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // with the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n    if (hasNonIncrementalResponses) {\n      var payloadFollowups = this._processResponses(nonIncrementalResponses);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        var updatedOwners = this._publishQueue.run(this._operation);\n\n        this._updateOperationTracker(updatedOwners);\n      }\n\n      this._processPayloadFollowups(payloadFollowups);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        if (this._incrementalPayloadsPending && !this._retainDisposable) {\n          this._retainDisposable = this._store.retain(this._operation);\n        }\n      }\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        // For the incremental case, we're only handling follow-up responses\n        // for already initiated operation (and we're not passing it to\n        // the run(...) call)\n        var _updatedOwners = this._publishQueue.run();\n\n        this._updateOperationTracker(_updatedOwners);\n      }\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    if (this._isSubscriptionOperation && RelayFeatureFlags.ENABLE_UNIQUE_SUBSCRIPTION_ROOT) {\n      // We attach the id to allow the `requestSubscription` to read from the store using\n      // the current id in its `onNext` callback\n      if (responsesWithData[0].extensions == null) {\n        // $FlowFixMe[cannot-write]\n        responsesWithData[0].extensions = {\n          __relay_subscription_root_id: this._operation.fragment.dataID\n        };\n      } else {\n        responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;\n      }\n    }\n\n    if (RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n      // OK: run once after each new payload\n      // If we have non-incremental responses, we passing `this._operation` to\n      // the publish queue here, which will later be passed to the store (via\n      // notify) to indicate that this operation caused the store to update\n      var _updatedOwners2 = this._publishQueue.run(hasNonIncrementalResponses ? this._operation : undefined);\n\n      if (hasNonIncrementalResponses) {\n        if (this._incrementalPayloadsPending && !this._retainDisposable) {\n          this._retainDisposable = this._store.retain(this._operation);\n        }\n      }\n\n      this._updateOperationTracker(_updatedOwners2);\n    }\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        getDataID: this._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n        shouldProcessClientComponents: this._shouldProcessClientComponents,\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          moduleImportPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._publishQueue.applyUpdate(update);\n    }); // OK: only called on construction and when receiving an optimistic payload from network,\n    // which doesn't fall-through to the regular next() handling\n\n    this._publishQueue.run();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {\n      var moduleImportPayloads = payload.moduleImportPayloads;\n      var operationLoader = this._operationLoader;\n      !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(moduleImportPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var moduleImportPayload = _step.value;\n          var operation = operationLoader.get(moduleImportPayload.operationReference);\n\n          if (operation == null) {\n            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);\n          } else {\n            var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);\n\n            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {\n    var selector = createNormalizationSelector(operation, moduleImportPayload.dataID, moduleImportPayload.variables);\n    return normalizeResponse({\n      data: moduleImportPayload.data\n    }, selector, moduleImportPayload.typeName, {\n      getDataID: this._getDataID,\n      path: moduleImportPayload.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {\n    var operation = getOperation(normalizationRootNode);\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {\n    var _this7 = this;\n\n    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisticUpdates.forEach(function (update) {\n        return _this7._publishQueue.applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisticUpdates)); // OK: always have to run() after an module import resolves async\n\n\n        _this7._publishQueue.run();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        return _this8._publishQueue.revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        getDataID: _this8._getDataID,\n        path: [],\n        reactFlightPayloadDeserializer: _this8._reactFlightPayloadDeserializer,\n        reactFlightServerErrorHandler: _this8._reactFlightServerErrorHandler,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        shouldProcessClientComponents: _this8._shouldProcessClientComponents\n      });\n\n      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          moduleImportPayloads = payload.moduleImportPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {\n        var operationLoader = _this9._operationLoader;\n        !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n        moduleImportPayloads.forEach(function (moduleImportPayload) {\n          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n              var updatedOwners = _this9._publishQueue.run();\n\n              _this9._updateOperationTracker(updatedOwners);\n            }\n\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    if (!this._isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n\n    if (RelayFeatureFlags.ENABLE_UNIQUE_SUBSCRIPTION_ROOT) {\n      var nextID = generateUniqueClientID();\n      this._operation = {\n        request: this._operation.request,\n        fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),\n        root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)\n      };\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {\n    var _this10 = this;\n\n    var node = operationLoader.get(moduleImportPayload.operationReference);\n\n    if (node != null) {\n      var operation = getOperation(node); // If the operation module is available synchronously, normalize the\n      // data synchronously.\n\n      this._handleModuleImportPayload(moduleImportPayload, operation);\n\n      this._maybeCompleteSubscriptionOperationTracking();\n    } else {\n      // Otherwise load the operation module and schedule a task to normalize\n      // the data when the module is available.\n      var _id3 = this._nextSubscriptionId++;\n\n      this._pendingModulePayloadsCount++;\n\n      var decrementPendingCount = function decrementPendingCount() {\n        _this10._pendingModulePayloadsCount--;\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n      // errors thrown by the load function, which is user-defined. Guard\n      // against that with Observable.from(new Promise(<work>)).\n\n\n      RelayObservable.from(new Promise(function (resolve, reject) {\n        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);\n      })).map(function (operation) {\n        if (operation != null) {\n          _this10._schedule(function () {\n            _this10._handleModuleImportPayload(moduleImportPayload, getOperation(operation)); // OK: always have to run after an async module import resolves\n\n\n            var updatedOwners = _this10._publishQueue.run();\n\n            _this10._updateOperationTracker(updatedOwners);\n          });\n        }\n      }).subscribe({\n        complete: function complete() {\n          _this10._complete(_id3);\n\n          decrementPendingCount();\n        },\n        error: function error(_error4) {\n          _this10._error(_error4);\n\n          decrementPendingCount();\n        },\n        start: function start(subscription) {\n          return _this10._start(_id3, subscription);\n        }\n      });\n    }\n  };\n\n  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {\n    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    this._publishQueue.commitPayload(this._operation, relayPayload);\n\n    if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n      var updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(updatedOwners);\n    }\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa;\n\n    // Update the label => path => placeholder map\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      if (!RelayFeatureFlags.ENABLE_BATCHED_STORE_UPDATES) {\n        var updatedOwners = this._publishQueue.run();\n\n        this._updateOperationTracker(updatedOwners);\n      }\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var parentID = placeholder.selector.dataID;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n\n    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      reactFlightPayloadDeserializer: this._reactFlightPayloadDeserializer,\n      reactFlightServerErrorHandler: this._reactFlightServerErrorHandler,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,\n      shouldProcessClientComponents: this._shouldProcessClientComponents\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    this._operationTracker.complete(this._operation.request);\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, relayPayload), {}, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};"]},"metadata":{},"sourceType":"script"}