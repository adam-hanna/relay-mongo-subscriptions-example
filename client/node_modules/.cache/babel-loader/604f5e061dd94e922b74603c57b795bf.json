{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreSubscriptions = require('./RelayStoreSubscriptions');\n\nvar RelayStoreSubscriptionsUsingMapByID = require('./RelayStoreSubscriptionsUsingMapByID');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar invariant = require('invariant');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayStoreUtils'),\n    ROOT_ID = _require.ROOT_ID,\n    ROOT_TYPE = _require.ROOT_TYPE;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 10;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    }); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._storeSubscriptions = RelayFeatureFlags.ENABLE_STORE_SUBSCRIPTIONS_REFACTOR === true ? new RelayStoreSubscriptionsUsingMapByID(options === null || options === void 0 ? void 0 : options.log) : new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log);\n    this._updatedRecordIDs = new Set();\n    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _this$_optimisticSour2, _options$target, _options$handlers;\n\n    var selector = operation.root;\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occured.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var target = (_options$target = options === null || options === void 0 ? void 0 : options.target) !== null && _options$target !== void 0 ? _options$target : source;\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var operationAvailability = DataChecker.check(source, target, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2.scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2.scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start',\n        sourceOperation: sourceOperation\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        sourceOperation: sourceOperation,\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs.clear();\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    return this._storeSubscriptions.subscribe(snapshot, callback);\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4.scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._storeSubscriptions.snapshotSubscriptions(this.getSource());\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this.scheduleGC();\n    }\n\n    this._storeSubscriptions.restoreSubscriptions();\n  };\n\n  _proto.scheduleGC = function scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will mark records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID); // $FlowFixMe[incompatible-call]\n\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      // ReactFlightClientResponses are lazy and only materialize when readRoot\n      // is called when we read the field, so if the record is a Flight field\n      // we always use the new record's data regardless of whether\n      // it actually changed. Let React take care of reconciliation instead.\n      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs.add(dataID);\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs.add(dataID);\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs.add(dataID);\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nmodule.exports = RelayModernStore;","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/relay-runtime/lib/store/RelayModernStore.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","_defineProperty2","DataChecker","RelayFeatureFlags","RelayModernRecord","RelayOptimisticRecordSource","RelayReader","RelayReferenceMarker","RelayStoreReactFlightUtils","RelayStoreSubscriptions","RelayStoreSubscriptionsUsingMapByID","RelayStoreUtils","deepFreeze","defaultGetDataID","invariant","resolveImmediate","_require","ROOT_ID","ROOT_TYPE","DEFAULT_RELEASE_BUFFER_SIZE","RelayModernStore","source","options","_this","_options$gcReleaseBuf","_options$gcScheduler","_options$getDataID","_options$log","_options$operationLoa","_gcRun","next","done","_gcScheduler","_gcStep","process","env","NODE_ENV","storeIDs","getRecordIDs","ii","length","record","get","freeze","_currentWriteEpoch","_gcHoldCounter","_gcReleaseBufferSize","gcReleaseBufferSize","gcScheduler","_getDataID","getDataID","_globalInvalidationEpoch","_invalidationSubscriptions","Set","_invalidatedRecordIDs","__log","log","_queryCacheExpirationTime","queryCacheExpirationTime","_operationLoader","operationLoader","_optimisticSource","_recordSource","_releaseBuffer","_roots","Map","_shouldScheduleGC","_storeSubscriptions","ENABLE_STORE_SUBSCRIPTIONS_REFACTOR","_updatedRecordIDs","_shouldProcessClientComponents","shouldProcessClientComponents","initializeRecordSource","_proto","prototype","getSource","_this$_optimisticSour","check","operation","_this$_optimisticSour2","_options$target","_options$handlers","selector","root","globalInvalidationEpoch","rootEntry","request","identifier","operationLastWrittenAt","epoch","status","target","handlers","operationAvailability","getAvailabilityStatus","fetchTime","retain","_this2","id","disposed","dispose","refCount","rootEntryIsStale","Date","now","scheduleGC","push","_id","shift","filter","set","lookup","snapshot","read","notify","sourceOperation","invalidateStore","_this3","name","updatedOwners","updateSubscriptions","forEach","subscription","_updateInvalidationSubscription","updatedRecordIDs","invalidatedRecordIDs","clear","node","params","operationKind","temporaryRootEntry","publish","idsMarkedForInvalidation","_this$_optimisticSour3","updateTargetFromSource","optimistic","subscribe","callback","holdGC","_this4","toJSON","__getUpdatedRecordIDs","lookupInvalidationState","dataIDs","_this5","invalidations","dataID","_RelayModernRecord$ge","getInvalidationEpoch","checkInvalidationState","prevInvalidationState","latestInvalidationState","currentInvalidations","prevInvalidations","_iterator","_step","s","n","value","err","e","f","subscribeToInvalidationState","invalidationState","_this6","add","invalidatedStore","_this7","isSubscribedToInvalidatedIDs","some","has","snapshotSubscriptions","create","restore","restoreSubscriptions","_collect","__gc","gcRun","top","startEpoch","references","_iterator2","values","_step2","mark","size","remove","rootRecord","currentWriteEpoch","targetRecord","sourceRecord","nextRecord","clone","setValue","INVALIDATED_AT_KEY","getType","REACT_FLIGHT_TYPE_NAME","update","operationFetchTime","mostRecentlyInvalidatedAt","isStale","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreReactFlightUtils = require('./RelayStoreReactFlightUtils');\n\nvar RelayStoreSubscriptions = require('./RelayStoreSubscriptions');\n\nvar RelayStoreSubscriptionsUsingMapByID = require('./RelayStoreSubscriptionsUsingMapByID');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar invariant = require('invariant');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayStoreUtils'),\n    ROOT_ID = _require.ROOT_ID,\n    ROOT_TYPE = _require.ROOT_TYPE;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 10;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    });\n\n    // Prevent mutation of a record from outside the store.\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._storeSubscriptions = RelayFeatureFlags.ENABLE_STORE_SUBSCRIPTIONS_REFACTOR === true ? new RelayStoreSubscriptionsUsingMapByID(options === null || options === void 0 ? void 0 : options.log) : new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log);\n    this._updatedRecordIDs = new Set();\n    this._shouldProcessClientComponents = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents;\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _this$_optimisticSour2, _options$target, _options$handlers;\n\n    var selector = operation.root;\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occured.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var target = (_options$target = options === null || options === void 0 ? void 0 : options.target) !== null && _options$target !== void 0 ? _options$target : source;\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var operationAvailability = DataChecker.check(source, target, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2.scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2.scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start',\n        sourceOperation: sourceOperation\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        sourceOperation: sourceOperation,\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs.clear();\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    return this._storeSubscriptions.subscribe(snapshot, callback);\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this4 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this4._gcHoldCounter > 0) {\n        _this4._gcHoldCounter--;\n\n        if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {\n          _this4.scheduleGC();\n\n          _this4._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this5 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this5.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this6 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this6._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this7 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this7._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._storeSubscriptions.snapshotSubscriptions(this.getSource());\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this.scheduleGC();\n    }\n\n    this._storeSubscriptions.restoreSubscriptions();\n  };\n\n  _proto.scheduleGC = function scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will mark records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID); // $FlowFixMe[incompatible-call]\n\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      // ReactFlightClientResponses are lazy and only materialize when readRoot\n      // is called when we read the field, so if the record is a Flight field\n      // we always use the new record's data regardless of whether\n      // it actually changed. Let React take care of reconciliation instead.\n      var nextRecord = RelayModernRecord.getType(targetRecord) === RelayStoreReactFlightUtils.REACT_FLIGHT_TYPE_NAME ? sourceRecord : RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs.add(dataID);\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs.add(dataID);\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs.add(dataID);\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nmodule.exports = RelayModernStore;"]},"metadata":{},"sourceType":"script"}