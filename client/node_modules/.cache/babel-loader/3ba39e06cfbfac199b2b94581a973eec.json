{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    isPromise = _require.isPromise;\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, value, networkSubscription, onDispose) {\n  var currentValue = value;\n  var retainCount = 0;\n  var retainDisposable = null;\n  var releaseTemporaryRetain = null;\n  var currentNetworkSubscription = networkSubscription;\n\n  var retain = function retain(environment) {\n    retainCount++;\n\n    if (retainCount === 1) {\n      retainDisposable = environment.retain(operation);\n    }\n\n    return {\n      dispose: function dispose() {\n        retainCount = Math.max(0, retainCount - 1);\n\n        if (retainCount === 0) {\n          !(retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n          retainDisposable.dispose();\n          retainDisposable = null;\n        }\n\n        onDispose(cacheEntry);\n      }\n    };\n  };\n\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return retainCount;\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      // NOTE: If we're executing in a server environment, there's no need\n      // to create temporary retains, since the component will never commit.\n      if (environment.isServer()) {\n        return {\n          dispose: function dispose() {}\n        };\n      } // NOTE: temporaryRetain is called during the render phase. However,\n      // given that we can't tell if this render will eventually commit or not,\n      // we create a timer to autodispose of this retain in case the associated\n      // component never commits.\n      // If the component /does/ commit, permanentRetain will clear this timeout\n      // and permanently retain the data.\n\n\n      var disposable = retain(environment);\n      var releaseQueryTimeout = null;\n\n      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n        releaseTemporaryRetain = null;\n        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n\n        if (retainCount <= 0 && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n      };\n\n      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release\n      // the previous temporary retain after we re-establish a new one, since\n      // we only ever need a single temporary retain until the permanent retain is\n      // established.\n      // temporaryRetain may be called multiple times by React during the render\n      // phase, as well as multiple times by other query components that are\n      // rendering the same query/variables.\n\n      if (releaseTemporaryRetain != null) {\n        releaseTemporaryRetain();\n      }\n\n      releaseTemporaryRetain = localReleaseTemporaryRetain;\n      return {\n        dispose: function dispose() {\n          releaseTemporaryRetain && releaseTemporaryRetain();\n        }\n      };\n    },\n    permanentRetain: function permanentRetain(environment) {\n      var disposable = retain(environment);\n\n      if (releaseTemporaryRetain != null) {\n        releaseTemporaryRetain();\n        releaseTemporaryRetain = null;\n      }\n\n      return {\n        dispose: function dispose() {\n          disposable.dispose();\n\n          if (retainCount <= 0 && currentNetworkSubscription != null) {\n            currentNetworkSubscription.unsubscribe();\n          }\n        }\n      };\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      if (cacheEntry.getRetainCount() <= 0) {\n        _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n      }\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue) || cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n          observerStart && observerStart(subscription);\n        },\n        next: function next() {\n          var snapshot = environment.lookup(operation.fragment);\n\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, _queryResult, networkSubscription);\n\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n          observerNext && observerNext(snapshot);\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, _error, networkSubscription);\n\n          cacheEntry.setValue(_error);\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};","map":{"version":3,"sources":["/home/adamhanna/apps/relay-mongo-subscriptions-example/client/node_modules/react-relay/lib/relay-hooks/QueryResource.js"],"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","LRUCache","invariant","_require","isPromise","CACHE_CAPACITY","DEFAULT_FETCH_POLICY","DATA_RETENTION_TIMEOUT","WEAKMAP_SUPPORTED","WeakMap","getQueryCacheIdentifier","environment","operation","maybeFetchPolicy","maybeRenderPolicy","cacheBreaker","fetchPolicy","renderPolicy","UNSTABLE_getDefaultRenderPolicy","cacheIdentifier","concat","request","identifier","getQueryResult","rootFragmentRef","__id","fragment","dataID","__fragments","node","name","variables","__fragmentOwner","fragmentNode","fragmentRef","nextID","createCacheEntry","value","networkSubscription","onDispose","currentValue","retainCount","retainDisposable","releaseTemporaryRetain","currentNetworkSubscription","retain","dispose","Math","max","process","env","NODE_ENV","cacheEntry","id","getValue","setValue","val","getRetainCount","getNetworkSubscription","setNetworkSubscription","subscription","unsubscribe","temporaryRetain","isServer","disposable","releaseQueryTimeout","localReleaseTemporaryRetain","clearTimeout","setTimeout","permanentRetain","QueryResourceImpl","_this","_cache","_environment","create","_proto","prototype","prepare","fetchObservable","observer","profilerContext","prepareWithIdentifier","get","temporaryRetainDisposable","_fetchAndSaveQuery","observerUnsubscribe","cachedValue","Error","queryResult","_getOrCreateCacheEntry","__log","resourceID","TESTS_ONLY__getCacheEntry","_clearCacheEntry","set","_this2","queryAvailability","check","queryStatus","status","hasFullQuery","canPartialRender","shouldFetch","shouldAllowRender","resolveNetworkPromise","_cacheEntry","_queryResult","subscribe","start","observerStart","next","snapshot","lookup","observerNext","error","_error","observerError","complete","observerComplete","_cacheEntry2","networkPromise","Promise","resolve","displayName","createQueryResource","dataResources","Map","getQueryResourceForEnvironment","cached","newDataResource","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,cAAc,GAAGF,sBAAsB,CAACC,OAAO,CAAC,sCAAD,CAAR,CAA3C;;AAEA,IAAIE,gBAAgB,GAAGH,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAtB;;AAEA,IAAII,SAAS,GAAGJ,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,eAAD,CAAtB;AAAA,IACIM,SAAS,GAAGD,QAAQ,CAACC,SADzB;;AAGA,IAAIC,cAAc,GAAG,IAArB;AACA,IAAIC,oBAAoB,GAAG,kBAA3B;AACA,IAAIC,sBAAsB,GAAG,IAAI,EAAJ,GAAS,IAAtC;AACA,IAAIC,iBAAiB,GAAG,OAAOC,OAAP,KAAmB,UAA3C;;AAEA,SAASC,uBAAT,CAAiCC,WAAjC,EAA8CC,SAA9C,EAAyDC,gBAAzD,EAA2EC,iBAA3E,EAA8FC,YAA9F,EAA4G;AAC1G,MAAIC,WAAW,GAAGH,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2DA,gBAA3D,GAA8EP,oBAAhG;AACA,MAAIW,YAAY,GAAGH,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAK,KAAK,CAAzD,GAA6DA,iBAA7D,GAAiFH,WAAW,CAACO,+BAAZ,EAApG;AACA,MAAIC,eAAe,GAAG,GAAGC,MAAH,CAAUJ,WAAV,EAAuB,GAAvB,EAA4BI,MAA5B,CAAmCH,YAAnC,EAAiD,GAAjD,EAAsDG,MAAtD,CAA6DR,SAAS,CAACS,OAAV,CAAkBC,UAA/E,CAAtB;;AAEA,MAAIP,YAAY,IAAI,IAApB,EAA0B;AACxB,WAAO,GAAGK,MAAH,CAAUD,eAAV,EAA2B,GAA3B,EAAgCC,MAAhC,CAAuCL,YAAvC,CAAP;AACD;;AAED,SAAOI,eAAP;AACD;;AAED,SAASI,cAAT,CAAwBX,SAAxB,EAAmCO,eAAnC,EAAoD;AAClD,MAAIK,eAAe,GAAG;AACpBC,IAAAA,IAAI,EAAEb,SAAS,CAACc,QAAV,CAAmBC,MADL;AAEpBC,IAAAA,WAAW,EAAE,CAAC,GAAG5B,gBAAgB,CAAC,SAAD,CAApB,EAAiC,EAAjC,EAAqCY,SAAS,CAACc,QAAV,CAAmBG,IAAnB,CAAwBC,IAA7D,EAAmElB,SAAS,CAACS,OAAV,CAAkBU,SAArF,CAFO;AAGpBC,IAAAA,eAAe,EAAEpB,SAAS,CAACS;AAHP,GAAtB;AAKA,SAAO;AACLF,IAAAA,eAAe,EAAEA,eADZ;AAELc,IAAAA,YAAY,EAAErB,SAAS,CAACS,OAAV,CAAkBQ,IAAlB,CAAuBH,QAFhC;AAGLQ,IAAAA,WAAW,EAAEV,eAHR;AAILZ,IAAAA,SAAS,EAAEA;AAJN,GAAP;AAMD;;AAED,IAAIuB,MAAM,GAAG,MAAb;;AAEA,SAASC,gBAAT,CAA0BjB,eAA1B,EAA2CP,SAA3C,EAAsDyB,KAAtD,EAA6DC,mBAA7D,EAAkFC,SAAlF,EAA6F;AAC3F,MAAIC,YAAY,GAAGH,KAAnB;AACA,MAAII,WAAW,GAAG,CAAlB;AACA,MAAIC,gBAAgB,GAAG,IAAvB;AACA,MAAIC,sBAAsB,GAAG,IAA7B;AACA,MAAIC,0BAA0B,GAAGN,mBAAjC;;AAEA,MAAIO,MAAM,GAAG,SAASA,MAAT,CAAgBlC,WAAhB,EAA6B;AACxC8B,IAAAA,WAAW;;AAEX,QAAIA,WAAW,KAAK,CAApB,EAAuB;AACrBC,MAAAA,gBAAgB,GAAG/B,WAAW,CAACkC,MAAZ,CAAmBjC,SAAnB,CAAnB;AACD;;AAED,WAAO;AACLkC,MAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1BL,QAAAA,WAAW,GAAGM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYP,WAAW,GAAG,CAA1B,CAAd;;AAEA,YAAIA,WAAW,KAAK,CAApB,EAAuB;AACrB,YAAEC,gBAAgB,IAAI,IAAtB,IAA8BO,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCjD,SAAS,CAAC,KAAD,EAAQ,+DAA+D,uDAAvE,CAAjD,GAAmLA,SAAS,CAAC,KAAD,CAA1N,GAAoO,KAAK,CAAzO;AACAwC,UAAAA,gBAAgB,CAACI,OAAjB;AACAJ,UAAAA,gBAAgB,GAAG,IAAnB;AACD;;AAEDH,QAAAA,SAAS,CAACa,UAAD,CAAT;AACD;AAXI,KAAP;AAaD,GApBD;;AAsBA,MAAIA,UAAU,GAAG;AACfjC,IAAAA,eAAe,EAAEA,eADF;AAEfkC,IAAAA,EAAE,EAAElB,MAAM,EAFK;AAGfmB,IAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5B,aAAOd,YAAP;AACD,KALc;AAMfe,IAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkBC,GAAlB,EAAuB;AAC/BhB,MAAAA,YAAY,GAAGgB,GAAf;AACD,KARc;AASfC,IAAAA,cAAc,EAAE,SAASA,cAAT,GAA0B;AACxC,aAAOhB,WAAP;AACD,KAXc;AAYfiB,IAAAA,sBAAsB,EAAE,SAASA,sBAAT,GAAkC;AACxD,aAAOd,0BAAP;AACD,KAdc;AAefe,IAAAA,sBAAsB,EAAE,SAASA,sBAAT,CAAgCC,YAAhC,EAA8C;AACpE,UAAIhB,0BAA0B,IAAI,IAAlC,EAAwC;AACtCA,QAAAA,0BAA0B,CAACiB,WAA3B;AACD;;AAEDjB,MAAAA,0BAA0B,GAAGgB,YAA7B;AACD,KArBc;AAsBfE,IAAAA,eAAe,EAAE,SAASA,eAAT,CAAyBnD,WAAzB,EAAsC;AACrD;AACA;AACA,UAAIA,WAAW,CAACoD,QAAZ,EAAJ,EAA4B;AAC1B,eAAO;AACLjB,UAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB,CAAE;AADzB,SAAP;AAGD,OAPoD,CAOnD;AACF;AACA;AACA;AACA;AACA;;;AAGA,UAAIkB,UAAU,GAAGnB,MAAM,CAAClC,WAAD,CAAvB;AACA,UAAIsD,mBAAmB,GAAG,IAA1B;;AAEA,UAAIC,2BAA2B,GAAG,SAASA,2BAAT,GAAuC;AACvEC,QAAAA,YAAY,CAACF,mBAAD,CAAZ;AACAA,QAAAA,mBAAmB,GAAG,IAAtB;AACAtB,QAAAA,sBAAsB,GAAG,IAAzB;AACAqB,QAAAA,UAAU,CAAClB,OAAX,GAJuE,CAIjD;AACtB;AACA;;AAEA,YAAIL,WAAW,IAAI,CAAf,IAAoBG,0BAA0B,IAAI,IAAtD,EAA4D;AAC1DA,UAAAA,0BAA0B,CAACiB,WAA3B;AACD;AACF,OAXD;;AAaAI,MAAAA,mBAAmB,GAAGG,UAAU,CAACF,2BAAD,EAA8B3D,sBAA9B,CAAhC,CA/BqD,CA+BkC;AACvF;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAIoC,sBAAsB,IAAI,IAA9B,EAAoC;AAClCA,QAAAA,sBAAsB;AACvB;;AAEDA,MAAAA,sBAAsB,GAAGuB,2BAAzB;AACA,aAAO;AACLpB,QAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1BH,UAAAA,sBAAsB,IAAIA,sBAAsB,EAAhD;AACD;AAHI,OAAP;AAKD,KAvEc;AAwEf0B,IAAAA,eAAe,EAAE,SAASA,eAAT,CAAyB1D,WAAzB,EAAsC;AACrD,UAAIqD,UAAU,GAAGnB,MAAM,CAAClC,WAAD,CAAvB;;AAEA,UAAIgC,sBAAsB,IAAI,IAA9B,EAAoC;AAClCA,QAAAA,sBAAsB;AACtBA,QAAAA,sBAAsB,GAAG,IAAzB;AACD;;AAED,aAAO;AACLG,QAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1BkB,UAAAA,UAAU,CAAClB,OAAX;;AAEA,cAAIL,WAAW,IAAI,CAAf,IAAoBG,0BAA0B,IAAI,IAAtD,EAA4D;AAC1DA,YAAAA,0BAA0B,CAACiB,WAA3B;AACD;AACF;AAPI,OAAP;AASD;AAzFc,GAAjB;AA2FA,SAAOT,UAAP;AACD;;AAED,IAAIkB,iBAAiB,GAAG,aAAa,YAAY;AAC/C,WAASA,iBAAT,CAA2B3D,WAA3B,EAAwC;AACtC,QAAI4D,KAAK,GAAG,IAAZ;;AAEA,KAAC,GAAGvE,gBAAgB,CAAC,SAAD,CAApB,EAAiC,IAAjC,EAAuC,kBAAvC,EAA2D,UAAUoD,UAAV,EAAsB;AAC/E,UAAIA,UAAU,CAACK,cAAX,MAA+B,CAAnC,EAAsC;AACpCc,QAAAA,KAAK,CAACC,MAAN,CAAa,QAAb,EAAuBpB,UAAU,CAACjC,eAAlC;AACD;AACF,KAJD;AAKA,SAAKsD,YAAL,GAAoB9D,WAApB;AACA,SAAK6D,MAAL,GAAcvE,QAAQ,CAACyE,MAAT,CAAgBrE,cAAhB,CAAd;AACD;;AAED,MAAIsE,MAAM,GAAGL,iBAAiB,CAACM,SAA/B;;AAEAD,EAAAA,MAAM,CAACE,OAAP,GAAiB,SAASA,OAAT,CAAiBjE,SAAjB,EAA4BkE,eAA5B,EAA6CjE,gBAA7C,EAA+DC,iBAA/D,EAAkFiE,QAAlF,EAA4FhE,YAA5F,EAA0GiE,eAA1G,EAA2H;AAC1I,QAAI7D,eAAe,GAAGT,uBAAuB,CAAC,KAAK+D,YAAN,EAAoB7D,SAApB,EAA+BC,gBAA/B,EAAiDC,iBAAjD,EAAoEC,YAApE,CAA7C;AACA,WAAO,KAAKkE,qBAAL,CAA2B9D,eAA3B,EAA4CP,SAA5C,EAAuDkE,eAAvD,EAAwEjE,gBAAxE,EAA0FC,iBAA1F,EAA6GiE,QAA7G,EAAuHC,eAAvH,CAAP;AACD;AACD;AACF;AACA;AACA;AACA;AARE;;AAWAL,EAAAA,MAAM,CAACM,qBAAP,GAA+B,SAASA,qBAAT,CAA+B9D,eAA/B,EAAgDP,SAAhD,EAA2DkE,eAA3D,EAA4EjE,gBAA5E,EAA8FC,iBAA9F,EAAiHiE,QAAjH,EAA2HC,eAA3H,EAA4I;AACzK,QAAIrE,WAAW,GAAG,KAAK8D,YAAvB;AACA,QAAIzD,WAAW,GAAGH,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,KAAK,KAAK,CAAvD,GAA2DA,gBAA3D,GAA8EP,oBAAhG;AACA,QAAIW,YAAY,GAAGH,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAK,KAAK,CAAzD,GAA6DA,iBAA7D,GAAiFH,WAAW,CAACO,+BAAZ,EAApG,CAHyK,CAGtB;AACnJ;;AAEA,QAAIkC,UAAU,GAAG,KAAKoB,MAAL,CAAYU,GAAZ,CAAgB/D,eAAhB,CAAjB;;AAEA,QAAIgE,yBAAyB,GAAG,IAAhC;;AAEA,QAAI/B,UAAU,IAAI,IAAlB,EAAwB;AACtB;AACA;AACA;AACAA,MAAAA,UAAU,GAAG,KAAKgC,kBAAL,CAAwBjE,eAAxB,EAAyCP,SAAzC,EAAoDkE,eAApD,EAAqE9D,WAArE,EAAkFC,YAAlF,EAAgG+D,eAAhG,EAAiH,CAAC,GAAGjF,cAAc,CAAC,SAAD,CAAlB,EAA+B,CAAC,GAAGA,cAAc,CAAC,SAAD,CAAlB,EAA+B,EAA/B,EAAmCgF,QAAnC,CAA/B,EAA6E,EAA7E,EAAiF;AAC7MlB,QAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBD,YAArB,EAAmC;AAC9C;AACA;AACA;AACA;AACA;AACA,cAAIuB,yBAAyB,IAAI,IAAjC,EAAuC;AACrCA,YAAAA,yBAAyB,CAACrC,OAA1B;AACD;;AAED,cAAIuC,mBAAmB,GAAGN,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAClB,WAAvF;AACAwB,UAAAA,mBAAmB,IAAIA,mBAAmB,CAACzB,YAAD,CAA1C;AACD;AAb4M,OAAjF,CAAjH,CAAb;AAeD,KA7BwK,CA6BvK;AACF;AACA;AACA;AACA;;;AAGAuB,IAAAA,yBAAyB,GAAG/B,UAAU,CAACU,eAAX,CAA2BnD,WAA3B,CAA5B;AACA,QAAI2E,WAAW,GAAGlC,UAAU,CAACE,QAAX,EAAlB;;AAEA,QAAIlD,SAAS,CAACkF,WAAD,CAAT,IAA0BA,WAAW,YAAYC,KAArD,EAA4D;AAC1D,YAAMD,WAAN;AACD;;AAED,WAAOA,WAAP;AACD;AACD;AACF;AACA;AACA;AACA;AAjDE;;AAoDAX,EAAAA,MAAM,CAAC9B,MAAP,GAAgB,SAASA,MAAT,CAAgB2C,WAAhB,EAA6BR,eAA7B,EAA8C;AAC5D,QAAIrE,WAAW,GAAG,KAAK8D,YAAvB;AACA,QAAItD,eAAe,GAAGqE,WAAW,CAACrE,eAAlC;AAAA,QACIP,SAAS,GAAG4E,WAAW,CAAC5E,SAD5B;;AAGA,QAAIwC,UAAU,GAAG,KAAKqC,sBAAL,CAA4BtE,eAA5B,EAA6CP,SAA7C,EAAwD4E,WAAxD,EAAqE,IAArE,CAAjB;;AAEA,QAAIxB,UAAU,GAAGZ,UAAU,CAACiB,eAAX,CAA2B1D,WAA3B,CAAjB;;AAEAA,IAAAA,WAAW,CAAC+E,KAAZ,CAAkB;AAChB5D,MAAAA,IAAI,EAAE,sBADU;AAEhBkD,MAAAA,eAAe,EAAEA,eAFD;AAGhBW,MAAAA,UAAU,EAAEvC,UAAU,CAACC;AAHP,KAAlB;;AAMA,WAAO;AACLP,MAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1BkB,QAAAA,UAAU,CAAClB,OAAX;AACD;AAHI,KAAP;AAKD,GApBD;;AAsBA6B,EAAAA,MAAM,CAACiB,yBAAP,GAAmC,SAASA,yBAAT,CAAmChF,SAAnC,EAA8CC,gBAA9C,EAAgEC,iBAAhE,EAAmFC,YAAnF,EAAiG;AAClI,QAAIJ,WAAW,GAAG,KAAK8D,YAAvB;AACA,QAAItD,eAAe,GAAGT,uBAAuB,CAACC,WAAD,EAAcC,SAAd,EAAyBC,gBAAzB,EAA2CC,iBAA3C,EAA8DC,YAA9D,CAA7C;AACA,WAAO,KAAKyD,MAAL,CAAYU,GAAZ,CAAgB/D,eAAhB,CAAP;AACD,GAJD;;AAMAwD,EAAAA,MAAM,CAACc,sBAAP,GAAgC,SAASA,sBAAT,CAAgCtE,eAAhC,EAAiDP,SAAjD,EAA4DyB,KAA5D,EAAmEC,mBAAnE,EAAwF;AACtH,QAAIc,UAAU,GAAG,KAAKoB,MAAL,CAAYU,GAAZ,CAAgB/D,eAAhB,CAAjB;;AAEA,QAAIiC,UAAU,IAAI,IAAlB,EAAwB;AACtBA,MAAAA,UAAU,GAAGhB,gBAAgB,CAACjB,eAAD,EAAkBP,SAAlB,EAA6ByB,KAA7B,EAAoCC,mBAApC,EAAyD,KAAKuD,gBAA9D,CAA7B;;AAEA,WAAKrB,MAAL,CAAYsB,GAAZ,CAAgB3E,eAAhB,EAAiCiC,UAAjC;AACD;;AAED,WAAOA,UAAP;AACD,GAVD;;AAYAuB,EAAAA,MAAM,CAACS,kBAAP,GAA4B,SAASA,kBAAT,CAA4BjE,eAA5B,EAA6CP,SAA7C,EAAwDkE,eAAxD,EAAyE9D,WAAzE,EAAsFC,YAAtF,EAAoG+D,eAApG,EAAqHD,QAArH,EAA+H;AACzJ,QAAIgB,MAAM,GAAG,IAAb;;AAEA,QAAIpF,WAAW,GAAG,KAAK8D,YAAvB,CAHyJ,CAGpH;AACrC;AACA;AACA;;AAEA,QAAIuB,iBAAiB,GAAGrF,WAAW,CAACsF,KAAZ,CAAkBrF,SAAlB,CAAxB;AACA,QAAIsF,WAAW,GAAGF,iBAAiB,CAACG,MAApC;AACA,QAAIC,YAAY,GAAGF,WAAW,KAAK,WAAnC;AACA,QAAIG,gBAAgB,GAAGD,YAAY,IAAInF,YAAY,KAAK,SAAjB,IAA8BiF,WAAW,KAAK,OAArF;AACA,QAAII,WAAJ;AACA,QAAIC,iBAAJ;;AAEA,QAAIC,qBAAqB,GAAG,SAASA,qBAAT,GAAiC,CAAE,CAA/D;;AAEA,YAAQxF,WAAR;AACE,WAAK,YAAL;AACE;AACEsF,UAAAA,WAAW,GAAG,KAAd;AACAC,UAAAA,iBAAiB,GAAG,IAApB;AACA;AACD;;AAEH,WAAK,kBAAL;AACE;AACED,UAAAA,WAAW,GAAG,CAACF,YAAf;AACAG,UAAAA,iBAAiB,GAAGF,gBAApB;AACA;AACD;;AAEH,WAAK,mBAAL;AACE;AACEC,UAAAA,WAAW,GAAG,IAAd;AACAC,UAAAA,iBAAiB,GAAGF,gBAApB;AACA;AACD;;AAEH,WAAK,cAAL;AACA;AACE;AACEC,UAAAA,WAAW,GAAG,IAAd;AACAC,UAAAA,iBAAiB,GAAG,KAApB;AACA;AACD;AA5BL,KAjByJ,CA8CvJ;AACF;AACA;AACA;;;AAGA,QAAIA,iBAAJ,EAAuB;AACrB,UAAIf,WAAW,GAAGjE,cAAc,CAACX,SAAD,EAAYO,eAAZ,CAAhC;;AAEA,UAAIsF,WAAW,GAAGrE,gBAAgB,CAACjB,eAAD,EAAkBP,SAAlB,EAA6B4E,WAA7B,EAA0C,IAA1C,EAAgD,KAAKK,gBAArD,CAAlC;;AAEA,WAAKrB,MAAL,CAAYsB,GAAZ,CAAgB3E,eAAhB,EAAiCsF,WAAjC;AACD;;AAED,QAAIH,WAAJ,EAAiB;AACf,UAAII,YAAY,GAAGnF,cAAc,CAACX,SAAD,EAAYO,eAAZ,CAAjC;;AAEA,UAAImB,mBAAJ;AACAwC,MAAAA,eAAe,CAAC6B,SAAhB,CAA0B;AACxBC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAehD,YAAf,EAA6B;AAClCtB,UAAAA,mBAAmB,GAAGsB,YAAtB;;AAEA,cAAIR,UAAU,GAAG2C,MAAM,CAACvB,MAAP,CAAcU,GAAd,CAAkB/D,eAAlB,CAAjB;;AAEA,cAAIiC,UAAJ,EAAgB;AACdA,YAAAA,UAAU,CAACO,sBAAX,CAAkCrB,mBAAlC;AACD;;AAED,cAAIuE,aAAa,GAAG9B,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC6B,KAAjF;AACAC,UAAAA,aAAa,IAAIA,aAAa,CAACjD,YAAD,CAA9B;AACD,SAZuB;AAaxBkD,QAAAA,IAAI,EAAE,SAASA,IAAT,GAAgB;AACpB,cAAIC,QAAQ,GAAGpG,WAAW,CAACqG,MAAZ,CAAmBpG,SAAS,CAACc,QAA7B,CAAf;;AAEA,cAAI0B,UAAU,GAAG2C,MAAM,CAACN,sBAAP,CAA8BtE,eAA9B,EAA+CP,SAA/C,EAA0D8F,YAA1D,EAAwEpE,mBAAxE,CAAjB;;AAEAc,UAAAA,UAAU,CAACG,QAAX,CAAoBmD,YAApB;AACAF,UAAAA,qBAAqB;AACrB,cAAIS,YAAY,GAAGlC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAC+B,IAAhF;AACAG,UAAAA,YAAY,IAAIA,YAAY,CAACF,QAAD,CAA5B;AACD,SAtBuB;AAuBxBG,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,MAAf,EAAuB;AAC5B,cAAI/D,UAAU,GAAG2C,MAAM,CAACN,sBAAP,CAA8BtE,eAA9B,EAA+CP,SAA/C,EAA0DuG,MAA1D,EAAkE7E,mBAAlE,CAAjB;;AAEAc,UAAAA,UAAU,CAACG,QAAX,CAAoB4D,MAApB;AACAX,UAAAA,qBAAqB;AACrBlE,UAAAA,mBAAmB,GAAG,IAAtB;AACAc,UAAAA,UAAU,CAACO,sBAAX,CAAkC,IAAlC;AACA,cAAIyD,aAAa,GAAGrC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACmC,KAAjF;AACAE,UAAAA,aAAa,IAAIA,aAAa,CAACD,MAAD,CAA9B;AACD,SAhCuB;AAiCxBE,QAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5Bb,UAAAA,qBAAqB;AACrBlE,UAAAA,mBAAmB,GAAG,IAAtB;;AAEA,cAAIc,UAAU,GAAG2C,MAAM,CAACvB,MAAP,CAAcU,GAAd,CAAkB/D,eAAlB,CAAjB;;AAEA,cAAIiC,UAAJ,EAAgB;AACdA,YAAAA,UAAU,CAACO,sBAAX,CAAkC,IAAlC;AACD;;AAED,cAAI2D,gBAAgB,GAAGvC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACsC,QAApF;AACAC,UAAAA,gBAAgB,IAAIA,gBAAgB,EAApC;AACD,SA7CuB;AA8CxBzD,QAAAA,WAAW,EAAEkB,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAAClB;AA9ClD,OAA1B;;AAiDA,UAAI0D,YAAY,GAAG,KAAK/C,MAAL,CAAYU,GAAZ,CAAgB/D,eAAhB,CAAnB;;AAEA,UAAI,CAACoG,YAAL,EAAmB;AACjB,YAAIC,cAAc,GAAG,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AAClDlB,UAAAA,qBAAqB,GAAGkB,OAAxB;AACD,SAFoB,CAArB,CADiB,CAGb;;AAEJF,QAAAA,cAAc,CAACG,WAAf,GAA6B,WAAW/G,SAAS,CAACc,QAAV,CAAmBG,IAAnB,CAAwBC,IAAnC,GAA0C,GAAvE;AACAyF,QAAAA,YAAY,GAAGnF,gBAAgB,CAACjB,eAAD,EAAkBP,SAAlB,EAA6B4G,cAA7B,EAA6ClF,mBAA7C,EAAkE,KAAKuD,gBAAvE,CAA/B;;AAEA,aAAKrB,MAAL,CAAYsB,GAAZ,CAAgB3E,eAAhB,EAAiCoG,YAAjC;AACD;AACF,KAjED,MAiEO;AACL,UAAID,gBAAgB,GAAGvC,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACsC,QAApF;AACAC,MAAAA,gBAAgB,IAAIA,gBAAgB,EAApC;AACD;;AAED,QAAIlE,UAAU,GAAG,KAAKoB,MAAL,CAAYU,GAAZ,CAAgB/D,eAAhB,CAAjB;;AAEA,MAAEiC,UAAU,IAAI,IAAhB,IAAwBH,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCjD,SAAS,CAAC,KAAD,EAAQ,4EAA4E,uDAApF,CAAjD,GAAgMA,SAAS,CAAC,KAAD,CAAjO,GAA2O,KAAK,CAAhP;;AAEAS,IAAAA,WAAW,CAAC+E,KAAZ,CAAkB;AAChB5D,MAAAA,IAAI,EAAE,qBADU;AAEhB6D,MAAAA,UAAU,EAAEvC,UAAU,CAACC,EAFP;AAGhBzC,MAAAA,SAAS,EAAEA,SAHK;AAIhBoE,MAAAA,eAAe,EAAEA,eAJD;AAKhBhE,MAAAA,WAAW,EAAEA,WALG;AAMhBC,MAAAA,YAAY,EAAEA,YANE;AAOhB+E,MAAAA,iBAAiB,EAAEA,iBAPH;AAQhBM,MAAAA,WAAW,EAAEA;AARG,KAAlB;;AAWA,WAAOlD,UAAP;AACD,GAlJD;;AAoJA,SAAOkB,iBAAP;AACD,CA3QoC,EAArC;;AA6QA,SAASsD,mBAAT,CAA6BjH,WAA7B,EAA0C;AACxC,SAAO,IAAI2D,iBAAJ,CAAsB3D,WAAtB,CAAP;AACD;;AAED,IAAIkH,aAAa,GAAGrH,iBAAiB,GAAG,IAAIC,OAAJ,EAAH,GAAmB,IAAIqH,GAAJ,EAAxD;;AAEA,SAASC,8BAAT,CAAwCpH,WAAxC,EAAqD;AACnD,MAAIqH,MAAM,GAAGH,aAAa,CAAC3C,GAAd,CAAkBvE,WAAlB,CAAb;;AAEA,MAAIqH,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAED,MAAIC,eAAe,GAAGL,mBAAmB,CAACjH,WAAD,CAAzC;AACAkH,EAAAA,aAAa,CAAC/B,GAAd,CAAkBnF,WAAlB,EAA+BsH,eAA/B;AACA,SAAOA,eAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA,mBAAmB,EAAEA,mBADN;AAEfG,EAAAA,8BAA8B,EAAEA,8BAFjB;AAGfrH,EAAAA,uBAAuB,EAAEA;AAHV,CAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    isPromise = _require.isPromise;\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, value, networkSubscription, onDispose) {\n  var currentValue = value;\n  var retainCount = 0;\n  var retainDisposable = null;\n  var releaseTemporaryRetain = null;\n  var currentNetworkSubscription = networkSubscription;\n\n  var retain = function retain(environment) {\n    retainCount++;\n\n    if (retainCount === 1) {\n      retainDisposable = environment.retain(operation);\n    }\n\n    return {\n      dispose: function dispose() {\n        retainCount = Math.max(0, retainCount - 1);\n\n        if (retainCount === 0) {\n          !(retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n          retainDisposable.dispose();\n          retainDisposable = null;\n        }\n\n        onDispose(cacheEntry);\n      }\n    };\n  };\n\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return retainCount;\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      // NOTE: If we're executing in a server environment, there's no need\n      // to create temporary retains, since the component will never commit.\n      if (environment.isServer()) {\n        return {\n          dispose: function dispose() {}\n        };\n      } // NOTE: temporaryRetain is called during the render phase. However,\n      // given that we can't tell if this render will eventually commit or not,\n      // we create a timer to autodispose of this retain in case the associated\n      // component never commits.\n      // If the component /does/ commit, permanentRetain will clear this timeout\n      // and permanently retain the data.\n\n\n      var disposable = retain(environment);\n      var releaseQueryTimeout = null;\n\n      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n        releaseTemporaryRetain = null;\n        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n\n        if (retainCount <= 0 && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n      };\n\n      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release\n      // the previous temporary retain after we re-establish a new one, since\n      // we only ever need a single temporary retain until the permanent retain is\n      // established.\n      // temporaryRetain may be called multiple times by React during the render\n      // phase, as well as multiple times by other query components that are\n      // rendering the same query/variables.\n\n      if (releaseTemporaryRetain != null) {\n        releaseTemporaryRetain();\n      }\n\n      releaseTemporaryRetain = localReleaseTemporaryRetain;\n      return {\n        dispose: function dispose() {\n          releaseTemporaryRetain && releaseTemporaryRetain();\n        }\n      };\n    },\n    permanentRetain: function permanentRetain(environment) {\n      var disposable = retain(environment);\n\n      if (releaseTemporaryRetain != null) {\n        releaseTemporaryRetain();\n        releaseTemporaryRetain = null;\n      }\n\n      return {\n        dispose: function dispose() {\n          disposable.dispose();\n\n          if (retainCount <= 0 && currentNetworkSubscription != null) {\n            currentNetworkSubscription.unsubscribe();\n          }\n        }\n      };\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      if (cacheEntry.getRetainCount() <= 0) {\n        _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n      }\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue) || cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n          observerStart && observerStart(subscription);\n        },\n        next: function next() {\n          var snapshot = environment.lookup(operation.fragment);\n\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, _queryResult, networkSubscription);\n\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n          observerNext && observerNext(snapshot);\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, _error, networkSubscription);\n\n          cacheEntry.setValue(_error);\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};"]},"metadata":{},"sourceType":"script"}